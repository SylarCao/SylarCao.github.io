<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title></title>
   <link href="" rel="self" type="application/atom+xml"/>
   <link href="" rel="alternate" type="text/html" />
   <updated>2015-04-09T16:49:01+08:00</updated>
   <id></id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>apple watch 预言</title>
     <link href="http://beiyuu.com/blog/2015/04/07/applewatch.html"/>
     <updated>2015-04-07T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/07/applewatch</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;今天是4.7，离4.10还有3天。
&lt;br /&gt;
我预言apple watch会火，至少不会死。
&lt;br /&gt;
鄙视网上各种说了一大堆理由而不做结论的文章。&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;转一片36kr的文章:  &lt;a href=&quot;http://36kr.com/p/531427.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;为什么说苹果表一定会死&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;section class=&quot;single-post-header&quot;&gt;&lt;div class=&quot;single-post-header__headline&quot;&gt;&lt;img alt=&quot;&quot; class=&quot;image&quot; height=&quot;337&quot; src=&quot;http://a.36krcnd.com/nil_class/583f3b46-7028-4ab0-a559-da0a382c8633.jpg&quot; width=&quot;620&quot; /&gt;&lt;/div&gt;&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么说苹果表一定会死&lt;/h2&gt;

&lt;section class=&quot;article&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;苹果表发布也有段时间了，而关于这块表到底如何也一直争论不休：正方从各个角度去说这块手表如何如何不好，什么性能低下续航垃圾一块电子表也好意思挑战奢侈表；而反方举起自己的大旗帜，拿出当年骂iPhone的诺基亚的下场，拿出当年骂iPad的人的ID，再拿出初代的苹果电脑ebay上的拍卖价格，高喊着你们这帮胆敢阻碍历史前进，可穿戴时代来临的蛆虫，一定会被碾得粉碎……&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是，我仍要说，这款手表是个垃圾，它注定失败。可穿戴时代，不是苹果这种保守表能够带领起来的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然，不列论据就是耍流氓。接下来就来看看，为什么这款手表注定失败。&lt;/p&gt;&lt;p&gt;不过在看失败之前，我们先来看看  iPhone 和iPad 为什么成功了。&lt;/p&gt;&lt;p&gt;其实，我觉得  iPhone 时代和  iPad 时代，对着苹果唱反调的都是属于科技宅、各种技术行家，事实上那个时候，普通民众并不关心苹果也不关注苹果，那时苹果的品牌影响力相比今天差得太远。在那个时代，苹果的哲学是如何把人们每天要用的东西做到极致，而不是像技术专家们那样，自己有什么需求就打造一个东西把那个专门需求完全满足。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而手机，则正是人们一定要用的东西。假设当年没有苹果，今天一样会人手一部手机，即便一直停留在诺基亚智能机时代。这个，你可以直接去看看手机市场在  iPhone 之前的发展幅度就能很清楚。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果，要做的并不是创造不存在的东西，而是在已经相对成熟的手机市场里给人们选择它的理由。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果给出的答案就是轻娱乐。&lt;/p&gt;&lt;p&gt;如今的地铁上，放眼望去，人们拿着手机就是看视频、看小说、玩游戏。所有的东西都可以碎片化轻度化，随时抽离，无聊时又能回来。人们不需要engagement，不需要强烈的沉浸感代入感，人们不想在公众面前展示自己真实的体验感受，只希望能够默默地装逼，一边看着自己的手机，斜眼看着旁边的人在玩啥。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;我记得我刚上大学时候，对手机完全没有兴趣，满脑子想的都是新的mp4。经常上中关村在线看新的mp4新闻，看着哪款蓝魔台电mp4又支持了哪种新的视频格式，是不是支持pdf，一如你们今天刷36氪。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而我的舍友看手机，后来还买了个psp。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;于那时的我而言，我觉得能随时随地看视频是再幸福不过的事；听歌是基本要求，至于游戏我主要玩PC游戏所以psp这种看起来很复杂的东西我就没关注过。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是，那时的我们都已经在渴求着有一个能够随身携带、消除坐车无聊的个人娱乐中心，我是视频和图书，而我舍友是游戏。对于在大城市成天上下班赶地铁的人来说，这是绝对的刚需。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;然后，iPhone 就是满足了这些刚需，把这些每个人都希望有的功能整合到了一起。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;没错，就是每个人都希望有的功能  – 因为这些功能没有学习门槛，我们从小就知道它们是娱乐。证据就是，为了随时看视频出现了mp4这种产品，为了随身玩游戏出现了psp、3ds这种产品，为了看电子书，即便是后来居上的kindle都竟然又从ipad手中分走了一片江山。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;iPhone在那个时代把这些功能都整合到一起，带来了整个移动互联网的兴起，这几乎是必然的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然，更大的争议是在  iPad 上。iPad 其实就是  iPhone 娱乐功能的升级版。即便是在mp4时代，我们已经在关注mp4的屏幕尺寸大小，因此初代的iPhone就屏幕本身肯定是满足不了那些天天消费视频、电子书和游戏的人的。iPad 为的就是满足这个。而手机越来越大，现在基本稳定在5-6寸之间，原因其实就是便携性和看视频、看书体验平衡的一个甜点而已，一旦满足之后，大家发现也懒得拿起  iPad 了。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这两款产品，成功得如此轻松而又必然，实际上也一点不出人意料。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是这款苹果表，是完全没有以上属性的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;让我们慢慢来  – 首先，这是一块手表吗？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然不是，关于这个话题争论得已经比较清楚了，手表本身的功能  – 看时间早就没有了，现在的传统手表代表的是身份地位，或者说  – 情怀，不可能被这种廉价的电子表所撼动，尤其在电子产品必须一年一换的前提下。当然，有人提到苹果表能让年轻人和中年人在身份地位的对拼中转换战场。这是个有意思的提法，不过现实中影响不大。的确，当你和富豪接触多了你会发现对于电子产品他们大多没有什么敏感度，倒不是因为他们是土豪，而是因为他们生活中有太多东西值得关注，而不是这种电子产品。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那么，这到底是什么呢？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;它只有一个定位可以走：成为一个个人中心。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;戴在手上，随时跟踪你的一举一动，知道你的位置，知道你的状态，你的身体健康，同时提供服务……一个健康向上的科幻未来设想中的美好道具。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;除了，它一点用也没有已。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;我们来看看：目前苹果表续航只有6个小时。一天一冲是必然的。当然，我们相信技术的演变，说不定哪天电池技术大革命，或者无线充电WIFI化，这都不是问题。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那我们再看看更重要的：现在苹果官方建议每个app一次让人的浏览时间不超过10秒。这能干什么？这样的话我在旅途中，还是得掏出手机/平板来解决无聊问题。嗯，没关系，我们假设苹果逆天，手表未来带投影功能（那么我们在地铁上就为面积打架了）。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而作为个人中心，不可否认取代银行卡/公交卡等等还是非常方便的，这也是我觉得手环这种奇葩设备唯一可能有用的点 – 而这个关键更大的推动层面会在政府，而非个人。不过，这些东西，手机上也一定都会有。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;因此，关键点之一来了：我们把苹果表和手机一对比，发现了在个人中心这个定义下的一些尴尬竞争：在目前科技方面的任何创意和应用，如果能放到手表上，在手机上绝对会先出现。比如说，各种取代银行卡的应用/支付系统，各种监控身体状况的传感器/计步器，这些都会先在手机上进行试水。这并不光光是看这个功能合适不合适的问题，而是手机厂商处于创新压力下，必然会做的事情。而作为个人中心，很重要的是和人的亲近感，手机早已不是问题，手表看起来离人更近，但这点差距对于如今的产品路线来说已经造不成什么影响。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;表能得到的研发资源，很难超过手机 – 那么多大厂需要靠手机活，但现在除了 Pebble 这种就是要踏可穿戴热潮的初创企业，没有几个厂是靠电子表活的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这就直接意味着，在个人中心这个层面，手表很难取代手机。电子设备这条路上，手机将还是会占据第一考虑位置，而不是手表。如果你要添置电子产品，你首先考虑的是手机，然后可能是平板/笔记本/个人台式，最后无聊了就是钱多任性了才会是手表。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那我们如果假设手机和手表在技术方面齐头并进，一直到手机的功能早就过剩，而手表终于能满足人的日常使用了，那么表是不是就翻身农奴当家了呢？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然不是，反而  – 到了这一天，它的末日就基本来了。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;假设有一天，在一块手表的 Form factor 里，我们也能满足我们日常的一切需求，能投影看视频，能社交，玩游戏，放ppt，甚至编辑文档视频，毫无担心续航问题……&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这个时候我们会问的是，一个智能眼镜能干什么？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;AR/VR 必将成为众人眼中的未来。那个时候，我们天天追逐的对象，必须就是新款的眼镜  -想想，微软最终的 Hololens 和同年发布的苹果表摆在你面前，你要哪个？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果表，也只能放在角落里搓灰了吧。&lt;/p&gt;&lt;/section&gt;

</content>
   </entry>
   
   <entry>
     <title>abc</title>
     <link href="http://beiyuu.com/mine/2015/04/04/sylarCV.html"/>
     <updated>2015-04-04T00:00:00+08:00</updated>
     <id>http://beiyuu.com/mine/2015/04/04/sylarCV</id>
     <content type="html">
</content>
   </entry>
   
   <entry>
     <title>理解 Objective-C Runtime【转】</title>
     <link href="http://beiyuu.com/blog/2015/04/02/runtime.html"/>
     <updated>2015-04-02T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/02/runtime</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20141008/9844.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.cocoachina.com/ios/20141008/9844.html&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;entry-content&quot;&gt;

&lt;p&gt;初学 Objective-C(以下简称ObjC) 的人很容易忽略一个 ObjC 特性 —— ObjC Runtime。这是因为这门语言很容易上手，几个小时就能学会怎么使用，所以程序员们往往会把时间都花在了解 Cocoa 框架以及调整自己的程序的表现上。然而 Runtime 应该是每一个 ObjC 都应该要了解的东西，至少要理解编译器会把&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[target doMethodWith:var1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(target,@selector(doMethodWith:),var1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的语句。理解 ObjC Runtime 的工作原理，有助于你更深入地去理解 ObjC 这门语言，理解你的 App 是怎样跑起来的。我想所有的 Mac/iPhone 开发者，无论水平如何，都会从中获益的。&lt;/p&gt;
&lt;h2&gt;ObjC Runtime 是开源的&lt;/h2&gt;
&lt;p&gt;ObjC Runtime 的代码是开源的，可以从这个站点下载： &lt;a href=&quot;http://opensource.apple.com/&quot;&gt;opensource.apple.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个是所有开源代码的链接： &lt;a href=&quot;http://www.opensource.apple.com/source/&quot;&gt;http://www.opensource.apple.com/source/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是ObjC rumtime 的源代码: &lt;a href=&quot;http://www.opensource.apple.com/source/objc4/&quot;&gt;http://www.opensource.apple.com/source/objc4/&lt;/a&gt;&lt;br /&gt;
4应该代表的是build版本而不是语言版本，现在是ObjC 2.0&lt;/p&gt;
&lt;h2&gt;动态 vs 静态语言&lt;/h2&gt;
&lt;p&gt;ObjC 是一种面向runtime(运行时)的语言，也就是说，它会尽可能地把代码执行的决策从编译和链接的时候，推迟到运行时。这给程序员写代码带来很大的灵活性，比如说你可以把消息转发给你想要的对象，或者随意交换一个方法的实现之类的。这就要求 runtime 能检测一个对象是否能对一个方法进行响应，然后再把这个方法分发到对应的对象去。我们拿 C 来跟 ObjC 对比一下。在 C 语言里面，一切从 main 函数开始，程序员写代码的时候是自上而下地，一个 C 的结构体或者说类吧，是不能把方法调用转发给其他对象的。举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt; stdio.h &amp;gt;

int main(int argc, const char **argv[])
{
        printf(&quot;Hello World!&quot;);
        return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码被编译器解析，优化后，会变成一堆汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text
 .align 4,0x90
 .globl _main
_main:
Leh_func_begin1:
 pushq %rbp
Llabel1:
 movq %rsp, %rbp
Llabel2:
 subq $16, %rsp
Llabel3:
 movq %rsi, %rax
 movl %edi, %ecx
 movl %ecx, -8(%rbp)
 movq %rax, -16(%rbp)
 xorb %al, %al
 leaq LC(%rip), %rcx
 movq %rcx, %rdi
 call _printf
 movl $0, -4(%rbp)
 movl -4(%rbp), %eax
 addq $16, %rsp
 popq %rbp
 ret
Leh_func_end1:
 .cstring
LC:
 .asciz &quot;Hello World!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，再链接 include 的库，完了生成可执行代码。对比一下 ObjC，当我们初学这门语言的时候教程是这么说滴：用中括号括起来的语句，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self doSomethingWithVar:var1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被编译器编译之后会变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(self,@selector(doSomethingWithVar:),var1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个 C 方法，传入了三个变量，self指针，要执行的方法 @selector(doSomethingWithVar:) 还有一个参数 var1。但是在这之后就不晓得发生什么了。&lt;/p&gt;
&lt;h2&gt;什么是 Objective-C Runtime?&lt;/h2&gt;
&lt;p&gt;ObjC Runtime 其实是一个 Runtime 库，基本上用 C 和汇编写的，这个库使得 C 语言有了面向对象的能力（脑中浮现当你乔帮主参观了施乐帕克的 SmallTalk 之后嘴角一抹浅笑）。这个库做的事前就是加载类的信息，进行方法的分发和转发之类的。&lt;/p&gt;
&lt;h2&gt;Objective-C Runtime 术语&lt;/h2&gt;
&lt;p&gt;再往下深谈之前咱先介绍几个术语。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 Runtimes
&lt;p&gt;目前说来Runtime有两种，一个 Modern Runtime 和一个 Legacy Runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2 Basic types of Methods
&lt;p&gt;一种 Instance Method，还有 Class Method。instance method 就是带“-”号的，需要实例化才能用的，如 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(void)doFoo; 

[aObj doFoot];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class Method 就是带“+”号的，类似于静态方法可以直接调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(id)alloc;

[ClassName alloc];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些方法跟 C 函数一样，就是一组代码，完成一个比较小的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(NSString *)movieTitle
{
    return @&quot;Futurama: Into the Wild Green Yonder&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Selector
&lt;p&gt;一个 Selector 事实上是一个 C 的结构体，表示的是一个方法。定义是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_selector  *SEL; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用起来就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SEL aSel = @selector(movieTitle); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以直接取一个selector，如果是传递消息（类似于C的方法调用）就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[target getMovieTitleForObject:obj];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 ObjC 里面，用&#39;[]’括起来的表达式就是一个消息。包括了一个 target，就是要接收消息的对象，一个要被调用的方法还有一些你要传递的参数。类似于 C 函数的调用，但是又有所不同。事实上上面这个语句你仅仅是传递了 ObjC 消息，并不代表它就会一定被执行。target 这个对象会检测是谁发起的这个请求，然后决策是要执行这个方法还是其他方法，或者转发给其他的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Class
&lt;p&gt;Class 的定义是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_class *Class;
typedef struct objc_object {
    Class isa;
} *id; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到这里这里有两个结构体，一个类结构体一个对象结构体。所有的 objc_object 对象结构体都有一个 isa 指针，这个 isa 指向它所属的类，在运行时就靠这个指针来检测这个对象是否可以响应一个 selector。完了我们看到最后有一个 id 指针。这个指针其实就只是用来代表一个 ObjC 对象，有点类似于 C++ 的泛型。当你拿到一个 id 指针之后，就可以获取这个对象的类，并且可以检测其是否响应一个 selector。这就是对一个 delegate 常用的调用方式啦。这样说还有点抽象，我们看看 LLVM/Clang 的文档对 Blocks 的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; struct Block_literal_1 {
    void *isa; // initialized to &amp;amp;_NSConcreteStackBlock or &amp;amp;_NSConcreteGlobalBlock
    int flags;
    int reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 {
 unsigned long int reserved; // NULL
     unsigned long int size;  // sizeof(struct Block_literal_1)
 // optional helper functions
     void (*copy_helper)(void *dst, void *src);
     void (*dispose_helper)(void *src); 
    } *descriptor;
    // imported variables
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到一个 block 是被设计成一个对象的，拥有一个 isa 指针，所以你可以对一个 block 使用 retain, release, copy 这些方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;IMP (Method Implementations)
&lt;p&gt;接下来看看啥是IMP。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef id (*IMP)(id self,SEL _cmd,...); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个 IMP 就是一个函数指针，这是由编译器生成的，当你发起一个 ObjC 消息之后，最终它会执行的那个代码，就是由这个函数指针指定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Objective-C Classes
&lt;p&gt;OK，回过头来看看一个 ObjC 的类。举一个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface MyClass : NSObject {
//vars
NSInteger counter;
}
//methods
-(void)doFoo;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个类我们可以写成如上代码，而在运行时，一个类就不仅仅是上面看到的这些东西了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到运行时一个类还关联了它的父类指针，类名，成员变量，方法，cache 还有附属的 protocol。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;那么类定义了对象并且自己也是个对象？这是咋整滴？&lt;/h2&gt;
&lt;p&gt;上面我提到过一个 ObjC 类同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做 &lt;del&gt;标签类&lt;/del&gt; 元类（Meta Class）的东西。当你发出一个消息的时候，比方说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[NSObject alloc];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你事实上是把这个消息发给了一个类对象（Class Object），这个类对象必须是一个 Meta Class 的实例，而这个 Meta Class 同时也是一个根 MetaClass 的实例。当你继承了 NSObject 成为其子类的时候，你的类指针就会指向 NSObject 为其父类。但是 Meta Class 不太一样，所有的 Meta Class 都指向根 Meta Class 为其父类。一个 Meta Class 持有所有能响应的方法。所以当 [NSObject alloc] 这条消息发出的时候，objc_msgSend() 这个方法会去 NSObject 它的 Meta Class 里面去查找是否有响应这个 selector 的方法，然后对 NSObject 这个类对象执行方法调用。&lt;/p&gt;
&lt;h2&gt;为啥我们要继承 Apple Classes&lt;/h2&gt;
&lt;p&gt;初学 Cocoa 开发的时候，多数教程都要我们继承一个类比方 NSObject，然后我们就开始 Coding 了。比方说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject *object = [[MyObject alloc] init];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语句用来初始化一个实例，类似于 C++ 的 new 关键字。这个语句首先会执行 MyObject 这个类的 +alloc 方法，Apple 的官方文档是这样说的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
  The isa instance variable of the new instance is initialized to a data structure that describes the class; memory for all other instance variables is set to 0.&lt;/p&gt;
&lt;p&gt;  新建的实例中，isa 成员变量会变初始化成一个数据结构体，用来描述所指向的类。其他的成员变量的内存会被置为0.
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以继承 Apple 的类我们不仅是获得了很多很好用的属性，而且也继承了这种内存分配的方法。&lt;/p&gt;
&lt;h2&gt;那么啥是 Class Cache(objc_cache *cache)&lt;/h2&gt;
&lt;p&gt;刚刚我们看到 runtime 里面有一个指针叫 objc_cache *cache，这是用来缓存方法调用的。现在我们知道一个实例对象被传递一个消息的时候，它会根据 isa 指针去查找能够响应这个消息的对象。但是实际上我们在用的时候，只有一部分方法是常用的，很多方法其实很少用或者根本用不到。比如一个object你可能从来都不用copy方法，那我要是每次调用的时候还去遍历一遍所有的方法那就太笨了。于是 cache 就应运而生了，每次你调用过一个方法，之后，这个方法就会被存到这个 cache 列表里面去，下次调用的时候 runtime 会优先去 cache 里面查找，提高了调用的效率。举一个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject *obj = [[MyObject alloc] init]; // MyObject 的父类是 NSObject

@implementation MyObject
-(id)init {
    if(self = [super init]){
        [self setVarA:@”blah”];
    }
    return self;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码是这样执行的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[MyObject alloc] 先被执行。但是由于 MyObject 这个类没有 +alloc 这个方法，于是去父类 NSObject 查找。&lt;/li&gt;
&lt;li&gt;检测 NSObject 是否响应 +alloc 方法，发现响应，于是检测 MyObject 类，根据其所需的内存空间大小开始分配内存空间，然后把 isa 指针指向 MyObject 类。那么 +alloc 就被加进 cache 列表里面了。&lt;/li&gt;
&lt;li&gt;完了执行 -init 方法，因为 MyObject 响应该方法，直接加入 cache。&lt;/li&gt;
&lt;li&gt;执行 self = [super init] 语句。这里直接通过 super 关键字调用父类的 init 方法，确保父类初始化成功，然后再执行自己的初始化逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OK，这就是一个很简单的初始化过程，在 NSObject 类里面，alloc 和 init　没做什么特别重大的事情，但是，ObjC 特性允许你的 alloc 和 init 返回的值不同，也就是说，你可以在你的 init 函数里面做一些很复杂的初始化操作，但是返回出去一个简单的对象，这就隐藏了类的复杂性。再举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt; Foundation/Foundation.h&amp;gt;

@interface MyObject : NSObject
{
 NSString *aString;
}

@property(retain) NSString *aString;

@end

@implementation MyObject

-(id)init
{
 if (self = [super init]) {
  [self setAString:nil];
 }
 return self;
}

@synthesize aString;

@end



int main (int argc, const char * argv[]) {
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

 id obj1 = [NSMutableArray alloc];
 id obj2 = [[NSMutableArray alloc] init];

 id obj3 = [NSArray alloc];
 id obj4 = [[NSArray alloc] initWithObjects:@&quot;Hello&quot;,nil];

 NSLog(@&quot;obj1 class is %@&quot;,NSStringFromClass([obj1 class]));
 NSLog(@&quot;obj2 class is %@&quot;,NSStringFromClass([obj2 class]));

 NSLog(@&quot;obj3 class is %@&quot;,NSStringFromClass([obj3 class]));
 NSLog(@&quot;obj4 class is %@&quot;,NSStringFromClass([obj4 class]));

 id obj5 = [MyObject alloc];
 id obj6 = [[MyObject alloc] init];

 NSLog(@&quot;obj5 class is %@&quot;,NSStringFromClass([obj5 class]));
 NSLog(@&quot;obj6 class is %@&quot;,NSStringFromClass([obj6 class]));

 [pool drain];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你是ObjC的初学者，那么你很可能会认为这段代码执的输出会是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSMutableArray
NSMutableArray 
NSArray
NSArray
MyObject
MyObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但事实上是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj1 class is __NSPlaceholderArray
obj2 class is NSCFArray
obj3 class is __NSPlaceholderArray
obj4 class is NSCFArray
obj5 class is MyObject
obj6 class is MyObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为 ObjC 是允许运行 +alloc 返回一个特定的类，而 init 方法又返回一个不同的类的。可以看到 NSMutableArray 是对普通数组的封装，内部实现是复杂的，但是对外隐藏了复杂性。&lt;/p&gt;
&lt;h2&gt;OK说回 objc_msgSend 这个方法&lt;/h2&gt;
&lt;p&gt;这个方法做的事情不少，举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self printMessageWithString:@&quot;Hello World!&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句语句被编译成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(self,@selector(printMessageWithString:),@&quot;Hello World!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法先去查找 self 这个对象或者其父类是否响应 @selector(printMessageWithString:)，如果从这个类的方法分发表或者 cache 里面找到了，就调用它对应的函数指针。如果找不到，那就会执行一些其他的东西。步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。&lt;/li&gt;
&lt;li&gt;检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。&lt;/li&gt;
&lt;li&gt;如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。&lt;/li&gt;
&lt;li&gt;如果 cache 找不到就找一下方法分发表。&lt;/li&gt;
&lt;li&gt;如果还找不到就要开始&lt;strong&gt;消息转发逻辑&lt;/strong&gt;了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在编译的时候，你定义的方法比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(int)doComputeWithNum:(int)aNum 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会编译成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后由 runtime 去调用指向你的这个方法的函数指针。那么之前我们说你发起消息其实不是对方法的直接调用，其实 Cocoa 还是提供了可以直接调用的方法的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 首先定义一个 C 语言的函数指针
int (computeNum *)(id,SEL,int);

// 使用 methodForSelector 方法获取对应与该 selector 的杉树指针，跟 objc_msgSend 方法拿到的是一样的
// **methodForSelector 这个方法是 Cocoa 提供的，不是 ObjC runtime 库提供的**
computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(doComputeWithNum:)];

// 现在可以直接调用该函数了，跟调用 C 函数是一样的
computeNum(obj,@selector(doComputeWithNum:),aNum); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你需要的话，你可以通过这种方式你来确保这个方法一定会被调用。&lt;/p&gt;
&lt;h2&gt;消息转发机制&lt;/h2&gt;
&lt;p&gt;在 ObjC 这门语言中，发送消息给一个并不响应这个方法的对象，是合法的，应该也是故意这么设计的。换句话说，我可以对任意一个对象传递任意一个消息（看起来有点像对任意一个类调用任意一个方法，当然事实上不是），当然如果最后找不到能调用的方法就会 Crash 掉。&lt;/p&gt;
&lt;p&gt;Apple 设计这种机制的原因之一就是——用来模拟多重继承（ObjC 原生是不支持多重继承的）。或者你希望把你的复杂设计隐藏起来。这种转发机制是 Runtime 非常重要的一个特性，大概的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找该类及其父类的 cahce 和方法分发表，在找不到的情况下执行2。&lt;/li&gt;
&lt;li&gt;执行 + (BOOL) resolveInstanceMethod:(SEL)aSEL 方法。
&lt;p&gt;这就给了程序员一次机会，可以告诉 runtime 在找不到改方法的情况下执行什么方法。举个栗子，先定义一个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void fooMethod(id obj, SEL _cmd)
{
 NSLog(@&quot;Doing Foo&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完了重载 resolveInstanceMethod 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)aSEL
{
    if(aSEL == @selector(doFoo:)){
        class_addMethod([self class],aSEL,(IMP)fooMethod,&quot;v@:&quot;);
        return YES;
    }
    return [super resolveInstanceMethod];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中  “v@:” 表示返回值和参数，这个符号涉及 Type Encoding，可以参考Apple的文档 &lt;a href=&quot;http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1&quot;&gt;ObjC Runtime Guide&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来 Runtime 会调用 – (id)forwardingTargetForSelector:(SEL)aSelector 方法。&lt;br /&gt;
这就给了程序员第二次机会，如果你没办法在自己的类里面找到替代方法，你就重载这个方法，然后把消息转给其他的Object。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if(aSelector == @selector(mysteriousMethod:)){
        return alternateObject;
    }
    return [super forwardingTargetForSelector:aSelector];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样你就可以把消息转给别人了。当然这里你不能 return self,不然就死循环了=.=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;最后，Runtime 会调用 – (void)forwardInvocation:(NSInvocation *)anInvocation  这个方法。NSInvocation 其实就是一条消息的封装。如果你能拿到 NSInvocation，那你就能修改这条消息的 target, selector 和 arguments。举个栗子：
&lt;pre&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation
{
    SEL invSEL = invocation.selector;

    if([altObject respondsToSelector:invSEL]) {
        [invocation invokeWithTarget:altObject];
    } else {
        [self doesNotRecognizeSelector:invSEL];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下 NSObject 对 forwardInvocation 的实现就是简单地执行 -doesNotRecognizeSelector: 这个方法，所以如果你想真正的在最后关头去转发消息你可以重载这个方法（好折腾-.-）。&lt;/p&gt;
&lt;p&gt;原文后面介绍了 Non Fragile ivars (Modern Runtime)， Objective-C Associated Objects 和 Hybrid vTable Dispatch。鉴于一是底层的可以不用理会，一是早司空见惯的不用详谈，还有一个是很简单的，就是一个建立在方法分发表里面填入默认常用的 method，所以有兴趣的读者可以自行查阅原文，这里就不详谈鸟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot;&gt;Objective-C Runtime Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html&quot;&gt;Objective-C Runtime Reference&lt;/a&gt;&lt;/p&gt;
					&lt;/div&gt;
</content>
   </entry>
   
   <entry>
     <title>小白学ruby【基本语法持续更新中】</title>
     <link href="http://beiyuu.com/blog/2015/03/24/%E5%B0%8F%E7%99%BD%E5%AD%A6ruby.html"/>
     <updated>2015-03-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/24/小白学ruby</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;本人从2012年开始学习ios，现在开始学习ruby，记录下学习过程中遇到的各种坑（个人分享经验，仅供参考）...
&lt;br /&gt;
转载请声明出处:  &lt;a href=&quot;http://sylarcao.github.io/blog/2015/03/24/%E5%B0%8F%E7%99%BD%E5%AD%A6ruby.html&quot;&gt;本文转自sylar的博客&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;ruby---&quot;&gt;ruby - 竟然没有函数重载&lt;/h2&gt;
&lt;ol style=&quot; margin-bottom: 8px; &quot;&gt;我以为有的，此处省略我被坑了34次……&lt;/ol&gt;
&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;参考连接:  &lt;a href=&quot;http://dtzq01.iteye.com/blog/1010557&quot;&gt;http://dtzq01.iteye.com/blog/1010557&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;ruby---random&quot;&gt;ruby - random数字&lt;/h2&gt;
&lt;scomment&gt;# 随机一个 0-9 的数字&lt;/scomment&gt;
&lt;p&gt;&lt;code&gt;random_number = Random.rand (10)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;ruby---for-&quot;&gt;ruby - for 循环&lt;/h2&gt;
&lt;scomment&gt; # for loop [1,10)   &lt;/scomment&gt;
&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;scomment&gt; # http://www.tutorialspoint.com/ruby/ruby_loops.htm &lt;/scomment&gt;

&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; for i in 1...10&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;js---&quot;&gt;js - 时间戳和日期&lt;/h2&gt;
&lt;scomment&gt;# moment 控件&lt;/scomment&gt;
&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;scomment&gt;# http://momentjs.com/&lt;/scomment&gt;
&lt;p style=&quot; line-height: 10px; margin-bottom: 30px; &quot;&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;var time_year_month = moment().format(&#39;YYYY-MM&#39;);&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2015-03)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var time = moment(&quot;2010-10-20 4:30&quot;, &quot;YYYY-MM-DD HH:mm&quot;).format(&quot;YYYY-MMMM&quot;); &lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2010-October)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var time = moment.unix(1427869321).format(&quot;YYYY-MM-DD HH:mm&quot;); &lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2015-04-01 14:22)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>合拍吧——我的第一个创业项目</title>
     <link href="http://beiyuu.com/blog/2015/03/24/%E5%90%88%E6%8B%8D%E5%90%A7.html"/>
     <updated>2015-03-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/24/合拍吧</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;感谢&lt;/h2&gt;
&lt;p&gt;感谢 陈zt 和 朱dl 二位程序猿前辈带领我做的这个app
&lt;br /&gt;
感谢 侯kl 把我安排到了这个项目&lt;/p&gt;

&lt;h2 id=&quot;app&quot;&gt;app简介&lt;/h2&gt;
&lt;blockquote&gt;&lt;p style=&quot;
    color: gray; margin-bottom: 13px;
&quot;&gt;还在独自无聊自拍？别OUT了——21世纪，没有互动就没有照片！&lt;br /&gt;
快来使用这款史无前例的合拍神器吧！&lt;br /&gt;
•眼花缭乱的合拍相纸——能够让你和各式朋友交互创造出千奇百怪的合影照片！&lt;br /&gt;
•及时分享的动态页面——让你实时掌握朋友们的每个瞬间！&lt;br /&gt;
•收纳合理的照片相集——精确归类你的各色照片！&lt;br /&gt;
•及时畅快的聊天系统——保证与合拍的TA沟通无障碍！&lt;br /&gt;
•随时查看附近潮人——三种搜索形态，各式筛选规则，让寻找趣人趣照变的易如反掌！&lt;br /&gt;
•一目了然的排行榜——闪亮的自己总会被发现，万众瞩目就在此间！&lt;br /&gt;
“与女神合体，和白马共存”不再是梦想，一切可能尽在——合——拍——吧！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这个app主要功能就是能让普(屌)通(丝)人能和自己的明星合照（参考下图）
&lt;img src=&quot;/images/1/img_paba_1.png&quot; alt=&quot;Alt text&quot; /&gt;
当然还包括了朋友圈聊天等基本的社交功能&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;制作感想&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个app主推的是拍照功能，当然这个功能肯定是大头，花了大部分时间做。
一开始，我们设计了各种背景和蒙板，还区分了横竖屏幕以及手机的4个方向来 适应我们不同的背景。
目的是为了让这个app看起来多样化，也就是绚丽多彩的功能。
可是后来发现，是我们把这个功能复杂化了，完全没有必要分4个场景的需要，就改成了一个。事实也证明这个简化是正确的，不但程序写起来方便了很多，而且根据现在的用户体验来讲，这个简化也是符合大流的。&lt;br /&gt;
我们的目的是为了让用户合拍，用户更在意的是和哪个明星，至于背景是什么，那是次要的，稍微唯美一点就基本都能接受了，不需要特别的绚丽多样。&lt;/li&gt;
  &lt;li&gt;登陆的界面，我们一共用了3个，新浪、QQ、人人。当时微信没那么火，在之后的版本中，我们把人人删了，增加了微信和手机号码。
这里我想说的是，在用第三方账号登陆的时候，尽量用native的，就是会跳转到那个app，而不要弹出一个界面让用户来输入用户名和密码之类的。
我们一开始做的是弹界面的，真的觉得很麻烦。&lt;/li&gt;
  &lt;li&gt;语音功能我们是一开始加进去的，后来发现大多数的用户还是偏向于用文字，语音的真的很少。
所以我在之后的项目中，客户如果不是特别需要，语音功能都是在2.0之后的版本才有的。&lt;/li&gt;
  &lt;li&gt;断网情况下用户是没法使用app的。这个究其原因还是我们实力不是很优秀以及但是sdk不是很完善。但是还是ios5到ios6的过度，本地保存数据的功能还处于待开发的阶段。
为了防止断网情况下的各种bug和闪退，但是就弹出登陆界面，让用户无法进入app，这个也是但是很多其他app处理断网的方法。
当然，这是一个很不好的用户体验，随着之后不断的发展，除了支付宝和各种手机银行的app等，几乎所有应用都支持断网使用。&lt;br /&gt;
这里也要感谢苹果的攻城狮的努力，才使得我们的开发变的越来越容易和简洁。&lt;/li&gt;
  &lt;li&gt;这个app在2013-11-09最后一次更新后就再也没有更新了，也就是宣告了失败。想想原因也就是运营的失败和产品本身没有足够的好，
再加上微信的迅猛发展，失败也是在情理之中的。&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>如何提升用户体验？手游用户的6个游戏阶段【转】</title>
     <link href="http://beiyuu.com/blog/2015/03/20/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C.html"/>
     <updated>2015-03-20T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/20/如何提升用户体验</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.sykong.com/2015/03/55385&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.sykong.com/2015/03/55385&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;text&quot;&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.sykong.com/wp-content/uploads/2015/03/162.jpg&quot; class=&quot;thickbox&quot; rel=&quot;gallery-55385&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-55387&quot; src=&quot;http://www.sykong.com/wp-content/uploads/2015/03/162.jpg&quot; alt=&quot;干货 | 如何提升用户体验？手游用户的6个游戏阶段&quot; width=&quot;600&quot; height=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;体验是一个很难描述的东西，我们经常假设玩家的体验跟我们游戏从业者的体验是一致的。但是很多情况下，我们从业者的游戏体验不等于玩家的游戏体验。因为从业者的用户属性和主流玩家的用户属性是不同的。下面就脱离游戏设计，介绍一下玩家玩游戏的6个体验阶段：&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段一：要不要玩?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阶段一就是玩家选择游戏的过程，我们先排除口碑相传带来的新用户，因为这个时分考验游戏的综合实力，所以这里我们只把场景放在一个特定的场景：用户在应用商店中寻找游戏时！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段一所处时间：&lt;/span&gt;进游戏前的下载阶段。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.icon；&lt;/p&gt;
&lt;p&gt;2.游戏名称；&lt;/p&gt;
&lt;p&gt;3.用户评星；&lt;/p&gt;
&lt;p&gt;4.游戏截图。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;手游市场，用户选择游戏都是很被动的，所以渠道推荐什么游戏，用户就玩什么游戏，而不是像端游时期那样，用户选择好了游戏，然后去下载。由于是被动的，在应用市场上，每一个可以被用户感知的因素都有可能影响到用户是否会下载。其中最关键的就是上面列出的4个因素。IP之所以那么重要就是因为他能非常明显的体现到ICON和名字上！有IP的产品会更容易获得新增用户!&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段二：能玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阶段二就是玩家下载好游戏，并且安装好之后(因为之前的步骤我们是无法控制的)。所以我们从玩家打开游戏开始。每个人刚玩一个游戏都会有一个“最初的印象”。这个最初印象很直接的影响到玩家对游戏的期待！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段二所处时间：&lt;/span&gt;3分钟以内；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.速度：&lt;/span&gt;加载，登陆，版本更新等这些需要玩家等待的，跟游戏内容无关的东西；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.流畅度：&lt;/span&gt;是否有崩溃，是否卡顿，是否有点击没有反应的情况，这些因素都是不可抗拒的阻止玩家正常游戏的情况；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;3.机型适配：&lt;/span&gt;机型适配是一个持续的工作，而不只是上线初期的事情，要不断优化。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;玩家在刚接触游戏的时候是很没有耐心的，如果在这个阶段让玩家遇到明显的“问题”，例如游戏闪退，游戏显示异常，一些按钮无法点击，游戏非常的卡顿……上面锁列出来的任何一个问题都很有可能让玩家感觉这是一个残次品，从而流失。&lt;/p&gt;
&lt;p&gt;除了出现明显的问题外，速度也是非常关键的！手游玩家玩游戏都是为了消遣，都在利用碎片时间在玩游戏，所以玩手机游戏的人都希望尽快玩到游戏，每一秒等待都会显得很痛苦!加上用户的使用环境错综复杂，多等几秒就可能存在没有网络的情况。手游的loading设计我认为非常重要！那是玩家对游戏的第一印象，也是玩家每天都需要等待的东西，值得花心思去优化。&lt;/p&gt;
&lt;p&gt;这个阶段考验的就是技术硬实力了，客户端优化的是否足够好，能够在大部分机型上流畅的运行，能否让玩家更快的进入游戏而不是等半天loading。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段三：好玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家只玩了一小会，这个时候玩家接触到的东西还很少，所以只能看到少量很表面的东西。如果感觉游戏还不错，愿意继续往下玩，就算是胜利!&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段三所处时间：&lt;/span&gt;3-10分钟。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.核心玩法：&lt;/span&gt;如果是已有的核心玩法，那么这个阶段就要在美术和UI/UE层面来跟竞品拉开差距。如果是创新的核心玩法，就要看目标用户是否觉得这个玩法好玩了。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.美术：&lt;/span&gt;游戏跟女人一样，美女大家都会愿意亲近，长的丑的谁都不爱搭理。美术就是游戏的脸面，美术好了玩家才有动力继续玩下去。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;3.UI/UE：&lt;/span&gt;这个部分跟游戏上手的容易程有直接关系，但是很少有人重视，不然不会出现现在这种情况：UI/UE都十分相似，并且很多体验很不好的地方。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;4.新手引导：&lt;/span&gt;新手引导不会成为加分项，只会成为减分项。新手引导的目的是让玩家从“不会玩”到“会玩”。如果玩家在新手引导之后还是不会玩，那么就很失败。如果真的存在新手引导结束后玩家还是不会玩，除了新手引导本身的设计之外，问题很可能是更底层的UI/UE。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;5.剧情：&lt;/span&gt;这里所指的剧情不是2个大头冒2个泡，出现几句对白。剧情首先要有视觉冲击力，要有酷炫的画面，合适的音乐和配音。这一步做好了也不一定是好的剧情，因为很多游戏一打开都会有一个酷炫的CG，但是CG跟游戏本身相差十万八千里，最多震撼一小会，就有从天堂掉落到现实的感觉。所以剧情不是越酷炫越好！现在很流行也是很恰当的剧情做法是结合到游戏中去，在游戏的真实场景中使用脚本做一些比较特别的剧情，来丰富游戏中的体验。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大部分游戏在核心玩法层面都很难拉开差距，而那些十分创新的玩法大部分也都不被大家所认可。所以在核心玩法上大家很难拉开差距，一旦拉开差距就是十分巨大的差距。这个阶段很大程度上是考验美术设计团队的能力，美术的好坏是最容易感受到的，也是前期影响用户最大的因素之一。交互设计是大部分游戏不被重视的一个环节，从现在市面上的游戏就能看出来，但是这个部分很重要，千万不要用新手引导来填这个部分的坑，治标不治本。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段四：会玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过了阶段三，玩家其实还不知道游戏到底要怎么玩，只是对核心玩法有一个初步的了解。不过随着等级的升高，玩家接触到的东西会越来越多，这个阶段就是玩家探索的过程，从接触新事物到熟悉新事物。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段四所处时间：&lt;/span&gt;3-30分钟。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.关卡设计：&lt;/span&gt;前期玩家是会在意关卡设计的，不要太难，也不要太简单。特别是关卡的丰富性和多样性，怪物的外形，技能，特点等最好多变一些，不然会快速产生疲劳感。这个阶段也可以在PVE的过程中加入一些剧情，来丰富PVE方面的体验。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.成就感：&lt;/span&gt;前期的成就感都是设计好的，不是玩家争取的，成就感主要分质变和量变。只要设计好前期的产出，合理的分布到时间轴上，持续的给玩家带来刺激，玩家就更容易持续的玩下去。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家还是因为前10分钟觉得有意思，惯性的在继续玩游戏。这个阶段还处于摸索和熟悉的阶段，玩家并没有很明确的游戏目标。所以这个阶段要通过奖励、掉落等方式持续刺玩家的神经，让玩家不要感觉到枯燥，如果玩家感觉到枯燥，第二天就可能不会回来，也就是直接影响到次日留存。&lt;/p&gt;
&lt;p&gt;另外，这个阶段是“有趣——有追求”的过渡阶段。类似“先尝后买”，这个阶段送给玩家的东西都是让玩家先体验一下，体验后觉得不错就会想要追去，目标感就自然而然的形成了。所以这个阶段不要送杂七杂八的东西，搞得玩家不明白得到了什么东西，最好直接在核心养成上让玩家不断强化。通过这种方式来慢慢树立目标感。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段五：有追求+可实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当玩家过了阶段4，探索带来的快感就没有了，所以需要帮助玩家树立自己的目标感，只有明确的目标感，才能让玩家继续留在游戏里。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段五所处时间：&lt;/span&gt;第二天至一周。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.目标感：&lt;/span&gt;缺失目标感是很多游戏的通病！玩家玩了半天不知道在玩什么，不明白自己想要什么，也不知道自己得到的那些奖励有什么用。游戏里有很多目标：任务，成就，等级，副本章节……但是这些都是游戏给玩家设计的目标感，而不是玩家自己真正想要追求的目标感，我所说的目标感是玩家自己建立的。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.新系统，新玩法：&lt;/span&gt;老的内容都会从熟悉到枯燥，需要新的内容来刺激玩家，让玩家保持一段时间的新鲜感。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家的新鲜感已经过去了，新内容的开放节奏大幅放缓。玩家在这个阶段已经开始重复劳动了(不断的打副本，重复刷材料，重复刷钱…)，玩家之所以愿意重复的劳动，是因为玩家有追求的目标。上个阶段玩家的成就感都是系统送的，那么这个阶段的成就感就需要玩家去通过努力争取了。&lt;/p&gt;
&lt;p&gt;最关键的是玩家有没有想要追求的东西！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段六：争强好胜，为了朋友&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“单机和网游最大的区别就在于互动。网游游戏就是拥有游戏元素的社区，从它的定义上来说，完全可以看出网游互动的重要。如果没有互动，那就是一个单机游戏而非网络游戏。网游中的玩家和单机游戏中的玩家的追求也是不一样的。”&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段六所处时间：&lt;/span&gt;一周以上。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.社交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.PVP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一周之后，游戏大部分的内容玩家都已经玩过了并且很熟悉了，或者说已经枯燥了。虽然没有将游戏内容全部消耗完(打通所有副本，获得所有武将……)但是玩家对现有内容已经提不起兴趣了。&lt;/p&gt;
&lt;p&gt;巴特尔将游戏用户分为4类：成就者，探险家，社交家，杀手。长期来看，成就和探索是很难满足的，因为他们高度依赖游戏内容。社交家和杀手的需求是可以持续满足的，因为他们不消耗游戏内容，只有有玩家，有竞争，就能持续满足这2类用户的需求。所以很多游戏在很末期的时候，用户上游戏不是为了玩游戏，而是进游戏跟这些战友聊聊天。&lt;/p&gt;
  &lt;/div&gt;
</content>
   </entry>
   
   <entry>
     <title>Hello World - 如何用 Github 建立个人博客</title>
     <link href="http://beiyuu.com/blog/2015/03/18/hello-world.html"/>
     <updated>2015-03-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/18/hello-world</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;某程序员退休后决定练习书法，于是重金购买文房四宝。一日，饭后突生雅兴，一番研墨拟纸，并点上上好檀香。定神片刻，泼墨挥毫，郑重地写下一行字：hello world!&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;感谢&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;感谢Github提供这样一个写博客的平台&lt;/li&gt;
  &lt;li&gt;感谢我的码友兼高中同桌&lt;a href=&quot;http://kimmykuang.github.io/&quot;&gt;Kimmy&lt;/a&gt;帮助我搭建这个博客&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-&quot;&gt;如何用 Github 建立个人博客&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Mac 环境
    &lt;ul&gt;
      &lt;li&gt;搭建好 Github 环境 &lt;a href=&quot;https://help.github.com/articles/set-up-git/&quot;&gt;安装教程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;新建一个 Repository 名字叫 yourname.github.io&lt;/li&gt;
      &lt;li&gt;提交一个 index.html 文件，然后 push 到 GitHub 的 master 分支&lt;/li&gt;
      &lt;li&gt;访问 yourname.github.io 就可以看到你上传的页面了&lt;/li&gt;
      &lt;li&gt;for example: &lt;br /&gt;
curl -X POST http://localhost:3000/smartcooler/pi -H “Content-Type:application/json” –data ‘{“type”:”temperature”, “data”:{“temp_f”:”1245”}}’
&lt;!-- + 本人是写ios出生，第一次建立网页，具体参考[这篇文章][link1] --&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;本地调试&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Mac 环境
    &lt;ul&gt;
      &lt;li&gt;安装 jekyll &lt;a href=&quot;http://kimmykuang.github.io/local-jekyll.html&quot;&gt;本地Jekyll环境的搭建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;打开 terminal 输入 &lt;code&gt;jekyll -v&lt;/code&gt; 查看版本&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre class=&quot;prettyprint linenums&quot;&gt;
  $ jekyll -v
  jekyll 2.5.3
&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;在 terminal 里 cd 到项目目录，输入 &lt;code&gt;jekyll serve --watch&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;浏览器访问 http://localhost:4000 即可&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可能遇到问题
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;/images/1/hello_world_error1.jpeg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;解决方案
        &lt;ul&gt;
          &lt;li&gt;ruby 版本到2.1.1 即可&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;rvm use ruby-2.1.1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;参考 &lt;a href=&quot;https://github.com/jekyll/jekyll/issues/2125&quot;&gt;https://github.com/jekyll/jekyll/issues/2125&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://beiyuu.com/github-pages&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;http://beiyuu.com/github-pages&lt;/a&gt;
&lt;br /&gt;
&lt;a href=&quot;http://kimmykuang.github.io/local-jekyll.html&quot;&gt;http://kimmykuang.github.io/local-jekyll.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- 注释 --&gt;

</content>
   </entry>
   
   <entry>
     <title>豆瓣FM(iOS 3.0)使用体会</title>
     <link href="http://beiyuu.com/opinion/2013/06/06/douban-fm.html"/>
     <updated>2013-06-06T00:00:00+08:00</updated>
     <id>http://beiyuu.com/opinion/2013/06/06/douban-fm</id>
     <content type="html">&lt;p&gt;豆瓣FM发布了全新设计的3.0版本，很多Feature不错：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;全新设计，清新、大气&lt;/li&gt;
    &lt;li&gt;操作流畅爽滑，运行交互效率很高&lt;/li&gt;
    &lt;li&gt;终于有歌词啦&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用中总结了一些体会，非常感性、毫无逻辑可言，看看就好：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;产品定位&lt;/h2&gt;

&lt;p&gt;豆瓣FM的产品定位，摘抄如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;它简单、易用，熟悉每个用户的脾气秉性，又能够聚合集体的智慧。无论是在家里、工作场所、咖啡厅还是交通工具上，无论是在休息、等候、娱乐还是工作时，它都能够提供完美、一致的体验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大家对推荐都满意，算法就不说了。简单易用来讲，国内的音乐APP中(虾米、QQ、百度等)，只有豆瓣是打开就播放，确实简单易用。&lt;/p&gt;

&lt;p&gt;这样的打开播放的产品定位下，使用场景就有些变化了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;交互框架&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;引导页&lt;/h3&gt;

&lt;p&gt;从App引导开始，新版FM就想让用户熟悉上下拉动的操作。&lt;/p&gt;

&lt;p&gt;豆瓣这次竟然使用了被吐槽无数次的App引导，还蛮让人意外的。是对交互设计不自信吗？观察周围使用的人以及我自己，基本上没人会去看引导页的内容，况且下拉的操作违反直觉，更容易招惹反感，播放页面也被蒙层，我直观感受是恐惧。&lt;/p&gt;

&lt;p&gt;登录和进入按钮被放置在引导页下方，并且位置尴尬，大约是为了让用户感受到下面还有内容，平衡了讨厌引导的用户需求(估计设计师自己也讨厌引导吧)，却牺牲了美感。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/8b8af2c8jw1e5eqcvmp9gj20oq0lp408.jpg&quot; alt=&quot;splash&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;上下拉&lt;/h3&gt;

&lt;p&gt;自从抽屉式导航普及开来之后，横滑展开设置成为一种默认操作。&lt;/p&gt;

&lt;p&gt;上下拉在虾米音乐中也有被应用，但和豆瓣的不同在于：虾米入口界面不是播放页，而是搜索、我的虾米、本地音乐这样的交互界面，此时播放页从下拉上来，更像是另一个维度的事情，并且主界面的交互有很多，播放页到另一个维度是很好理解的事情。硬套生活中所讲的横向、纵向的概念也完全讲的通。&lt;/p&gt;

&lt;p&gt;豆瓣FM的逻辑不完美在于，他的主页是播放页，选择兆赫更像是个设置，硬说他是另一个维度也没错，但是这两个的关系太平等（都只有一个），上下拉就显得违反直觉了。&lt;/p&gt;

&lt;p&gt;而且没人看引导，反直觉的上下拉动的交互，让很多人不知所措，顶部也没有标记表明那是可以拉动的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/8b8af2c8jw1e5eqd2xcj9j20oq0lpjv1.jpg&quot; alt=&quot;slide&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;设计细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;封面不清晰&lt;/li&gt;
&lt;li&gt;对话框关闭按钮在左边，为什么呢？&lt;/li&gt;
&lt;li&gt;兆赫不能搜索，连换一批也不能？更新说明说动态切换，怎么切换？&lt;/li&gt;
&lt;li&gt;暂停、播放按钮太小（上面显示广告也罢了，下面那么大的空间，完全可以利用起来）&lt;/li&gt;
&lt;li&gt;只支持上下拉的手势，却不支持左右后退的手势？（更新说明里我瞟见了手势两个字）&lt;/li&gt;
&lt;li&gt;顶部“正在同步”等状态栏，完全遮挡操作按钮，为什么不加后退手势这种标配呢？&lt;/li&gt;
&lt;li&gt;在上下拉的交互框架中，歌曲状态栏细节做的很到位（比如当上下拉到歌曲名称位置的时候，状态栏才会fix住），但是上拉拖动的时候，状态栏此时是拖动的把手，却自己不动弹，逻辑又奇怪了不是？&lt;/li&gt;
&lt;li&gt;其他的程序BUG，比如红心数目不对等等。&lt;/li&gt;
&lt;li&gt;如何收藏兆赫，研究许久才知道是长按。&lt;/li&gt;
&lt;li&gt;也是琢磨了半天才知道，点头像是进入设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/8b8af2c8jw1e5eqd8tkg5j20oq0lpjti.jpg&quot; alt=&quot;slide&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再重复一下，APP引导太可怕了！ 我说的全是废话，因为这个版本发布后，看起来好评如潮，哎。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>史蒂夫·乔布斯：遗失的访谈</title>
     <link href="http://beiyuu.com/opinion/2013/05/14/jobs-interview.html"/>
     <updated>2013-05-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/opinion/2013/05/14/jobs-interview</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;1、做公司就是做产品&lt;/h2&gt;

&lt;p&gt;乔布斯从12岁开始，就捣鼓着好玩有用的产品，在惠普兼职的那些日子，也让他体会到了科技的魅力，原来凭一个人的力量也可以有如此之大的影响力，也是在惠普他认识了沃兹尼亚克。&lt;/p&gt;

&lt;p&gt;Apple II发布时，乔布斯年仅21岁，从此之后，他的财富不断增加，23岁一百万，24岁一千万，25岁一亿美元。但是钱并不是乔布斯认为最重要的东西，重要的是人才、产品，是产品带给用户的价值。&lt;/p&gt;

&lt;p&gt;做产品要深入的每一个细节，要去控制成本，就必须知道每一个步骤的精确成本，他也建议所有人都去学习一下编程，学习这种思考问题的方式。&lt;/p&gt;

&lt;p&gt;乔布斯举了百事可乐的例子，来说明大公司为什么会失败，因为一旦公司做大，形成垄断市场之后，产品数十年也不会发生多大的变化，而且这些垄断的市场也很难再提高业绩，要提高业绩还得靠营销部门，最终营销人员挤走了产品人员，而营销人员并不懂产品，这情形在百事可乐这样的公司没问题，但在科技公司就会造成悲剧。&lt;/p&gt;

&lt;p&gt;光靠流程和制度，是不能让公司持续成功的，必须全心全意放在产品上。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2、如何使公司良好运转&lt;/h2&gt;

&lt;p&gt;对于传统行业来说，最好和普通之间，差距可能就是百分之几十的样子，但是对科技行业来说，最好的与普通的人才，能力的差距可能达百倍，所以一流的公司需要一流的人才，一流的人才也愿意与一流的人才共事。&lt;/p&gt;

&lt;p&gt;团队的协作过程，就像磨石机的工作过程一样，会有摩擦会有障碍，这是必然的，以乔布斯的理解来看，真正优秀的人，只想成功，不在乎是非，用事实说话，其他的都不重要，他认为优秀的人也不太需要你太在乎他们的自尊。&lt;/p&gt;

&lt;p&gt;大约这就是他被谣传暴戾的原因吧，从访谈中可以看的出，他确实不太在乎事实之外的东西，他自己也会犯错，别人也可以说服他，只要基于事实就好。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3、品位问题&lt;/h2&gt;

&lt;p&gt;毫无疑问，乔布斯的品位很好，他认为和在大学时旁听排版课程的关系密不可分，的确，内容永远都是最重要的，并且，字体设计那些细致入微的细节，也对他有很深的影响。&lt;/p&gt;

&lt;p&gt;微软是一个成功的公司，善于抓住机遇，但是他们的产品毫无品位，是三流的，或许没有苹果，微软的产品会更糟糕，没有灵魂，非常平庸，但是更令人可悲的是用户并不以为然。&lt;/p&gt;

&lt;p&gt;人类应该追求极致，并分享给同类。&lt;/p&gt;

&lt;p&gt;乔布斯也从来不觉得借鉴别人的创意是可耻的，笨拙的工匠只会抄，灵巧的工匠会借鉴的恰到好处，苹果的产品非常确切的说明了这个事实。&lt;/p&gt;

&lt;p&gt;6、70年代的嬉皮士运动给乔布斯留下了深刻印象，他认为嬉皮士是去努力寻找生活的真相的一群人，他们觉得生活不应该是父母过的那样。嬉皮士的出发点是可贵的。也正是因为这种精神，有人宁愿当诗人也不愿做银行家。&lt;/p&gt;

&lt;p&gt;乔布斯很欣赏这种精神，他也想把这种精神溶入到产品中。只要用户使用产品，就能感受到这种精神，如果与Macintosh的用户交谈，会发现他们喜爱这个产品，在此之前，你很少听人说真心喜欢某个商业产品——是的，但你可以从Macintosh感受到某种奇妙的东西。&lt;/p&gt;

&lt;!--&lt;iframe height=&quot;498&quot; width=&quot;510&quot; src=&quot;http://player.youku.com/embed/XNTUxNDY1NDY4&quot; frameborder=&quot;0&quot; style=&quot;margin:0 auto&quot;&gt;&lt;/iframe&gt;--&gt;

&lt;div style=&quot;text-align:center&quot;&gt;
&lt;embed src=&quot;http://player.youku.com/player.php/sid/XNTUxNDY1NDY4/v.swf&quot; allowfullscreen=&quot;true&quot; quality=&quot;high&quot; width=&quot;480&quot; height=&quot;400&quot; align=&quot;middle&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; /&gt;
&lt;/div&gt;
</content>
   </entry>
   
   <entry>
     <title>Tabby</title>
     <link href="http://beiyuu.com/project/2013/04/12/tabby.html"/>
     <updated>2013-04-12T00:00:00+08:00</updated>
     <id>http://beiyuu.com/project/2013/04/12/tabby</id>
     <content type="html">&lt;p&gt;用&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot;&gt;Tabby&lt;/a&gt;有一阵子了，最近把细节完善，发布在了Chrome Store。&lt;/p&gt;

&lt;p&gt;他的功能是，当你打开几十上百个Chrome标签，很占资源，不想加入书签，也不想存入Instapaper等Read It Later的东西，只看一次，但就是不想现在看，这时候只要在页面点击右键，选择“暂存到Tabby”即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-pro1.png&quot; alt=&quot;Tabby&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;你可以设置使用快捷键（默认关闭），要打开暂存的标签，只需点击Tabby的图标。因为使用了Chrome的书签，即使你卸载插件，还没来得及看的也不会丢失，也会默认同步到别的设备。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-pro2.png&quot; alt=&quot;Tabby&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;推荐一本书&lt;a href=&quot;http://read.douban.com/ebook/709141/?referral_code=e6acsgl3&quot; title=&quot;我是个年轻人，我心情不太好&quot;&gt;我是个年轻人，我心情不太好&lt;/a&gt;，当时是他的简介让我动心了一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我25岁，读过一个硕士，但是退学了。我被时间、空间、意义这些事情烦扰着。我知道的东西多得难以置信。我知道名字，年份。数以百计。我知道谁第一个上的珠穆朗玛峰。我知道谁导演了那些美国最蹩脚的肥皂剧。我知道亚里士多德讲的话是啥意思。我知道时间在太阳上会走得慢一点……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;但是，我知道这些有什么意义呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我的生活仍旧是一团糟。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;不，连一团糟都不是，它是一片空白。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我没有女朋友，甚至没有很好很好的朋友。我有一个哥哥，还有一个比我小很多、还在上幼儿园的“伙伴”。可他们也不算是朋友。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;要是我能有一种非常靠谱的感觉，觉得一切都会好起来，那该多好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不指望这本书能喂你多大一碗鸡汤，就是让你知道这个年纪的共同态，而且或许有解决办法。&lt;/p&gt;

&lt;p&gt;好吧，去下载插件吧：
&lt;a href=&quot;https://chrome.google.com/webstore/detail/tabby/pifnjkdglcfkfpdjdolfacpfdlgpdkhp&quot; title=&quot;Tabby&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;/images/other/Tabby-440.png&quot; alt=&quot;Tabby&quot; width=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

</content>
   </entry>
   
 
</feed>
