<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title></title>
   <link href="" rel="self" type="application/atom+xml"/>
   <link href="" rel="alternate" type="text/html" />
   <updated>2015-04-24T16:38:19+08:00</updated>
   <id></id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Auto Layout 使用心得 【转】</title>
     <link href="http://beiyuu.com/blog/2015/04/22/autolayout1.html"/>
     <updated>2015-04-22T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/22/autolayout1</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150422/11632.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.cocoachina.com/ios/20150422/11632.html&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;article class=&quot;markdown-body entry-content&quot; itemprop=&quot;mainContentOfPage&quot;&gt;&lt;h2&gt;
&lt;a id=&quot;user-content-auto-layout-使用心得系列文章代码仓库&quot; class=&quot;anchor&quot; href=&quot;#auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;《Auto Layout 使用心得》系列文章代码仓库&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;



&lt;h4&gt;
&lt;a id=&quot;user-content-1-auto-layout-使用心得一-初体验&quot; class=&quot;anchor&quot; href=&quot;#1-auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E4%B8%80-%E5%88%9D%E4%BD%93%E9%AA%8C&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;1. &lt;a href=&quot;http://lvwenhan.com/ios/430.html&quot;&gt;Auto Layout 使用心得（一）—— 初体验&lt;/a&gt;
&lt;/h4&gt;

&lt;h4&gt;
&lt;a id=&quot;user-content-2-auto-layout-使用心得二-实现三等分&quot; class=&quot;anchor&quot; href=&quot;#2-auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E4%BA%8C-%E5%AE%9E%E7%8E%B0%E4%B8%89%E7%AD%89%E5%88%86&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;2. &lt;a href=&quot;http://lvwenhan.com/ios/431.html&quot;&gt;Auto Layout 使用心得（二）—— 实现三等分&lt;/a&gt;
&lt;/h4&gt;

&lt;p&gt;搭建过程：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/436ae426ad98dd6ef07f1821a02b6a95e50893a1/687474703a2f2f6c7677656e68616e2e636f6d2f636f6e74656e742f75706c6f616466696c652f3230313530332f62356539313432353634373830302e676966&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/436ae426ad98dd6ef07f1821a02b6a95e50893a1/687474703a2f2f6c7677656e68616e2e636f6d2f636f6e74656e742f75706c6f616466696c652f3230313530332f62356539313432353634373830302e676966&quot; alt=&quot;pic&quot; data-canonical-src=&quot;http://lvwenhan.com/content/uploadfile/201503/b5e91425647800.gif&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;
&lt;a id=&quot;user-content-3-auto-layout-使用心得三-自定义-cell-并使用-auto-layout&quot; class=&quot;anchor&quot; href=&quot;#3-auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E4%B8%89-%E8%87%AA%E5%AE%9A%E4%B9%89-cell-%E5%B9%B6%E4%BD%BF%E7%94%A8-auto-layout&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;3. &lt;a href=&quot;http://lvwenhan.com/ios/441.html&quot;&gt;Auto Layout 使用心得（三）—— 自定义 cell 并使用 Auto Layout&lt;/a&gt;
&lt;/h4&gt;

&lt;h4&gt;
&lt;a id=&quot;user-content-4-auto-layout-使用心得四-22-行代码实现拖动回弹&quot; class=&quot;anchor&quot; href=&quot;#4-auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%9B%9B-22-%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%8B%96%E5%8A%A8%E5%9B%9E%E5%BC%B9&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;4. &lt;a href=&quot;http://lvwenhan.com/ios/442.html&quot;&gt;Auto Layout 使用心得（四）—— 22 行代码实现拖动回弹&lt;/a&gt;
&lt;/h4&gt;

&lt;p&gt;效果：&lt;br /&gt;
&lt;a href=&quot;https://camo.githubusercontent.com/d6ea9c60c94facd653176f84f6de4c942581757d/687474703a2f2f6c7677656e68616e2e636f6d2f636f6e74656e742f75706c6f616466696c652f3230313530342f62356539313432373838333537302e676966&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/d6ea9c60c94facd653176f84f6de4c942581757d/687474703a2f2f6c7677656e68616e2e636f6d2f636f6e74656e742f75706c6f616466696c652f3230313530342f62356539313432373838333537302e676966&quot; alt=&quot;pic&quot; data-canonical-src=&quot;http://lvwenhan.com/content/uploadfile/201504/b5e91427883570.gif&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;
&lt;a id=&quot;user-content-5-auto-layout-使用心得五-根据文字图片自动计算-uitableviewcell-高度&quot; class=&quot;anchor&quot; href=&quot;#5-auto-layout-%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E4%BA%94-%E6%A0%B9%E6%8D%AE%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97-uitableviewcell-%E9%AB%98%E5%BA%A6&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;5. &lt;a href=&quot;http://lvwenhan.com/ios/449.html&quot;&gt;Auto Layout 使用心得（五）—— 根据文字、图片自动计算 UITableViewCell 高度&lt;/a&gt;
&lt;/h4&gt;

&lt;p&gt;效果：&lt;br /&gt;
&lt;a href=&quot;https://camo.githubusercontent.com/1bf1439bd0ae913ee04b0e4285cc1a30fda2cb21/687474703a2f2f7374617469636f6e7361652e73696e616170702e636f6d2f696d616765732f352e676966&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/1bf1439bd0ae913ee04b0e4285cc1a30fda2cb21/687474703a2f2f7374617469636f6e7361652e73696e616170702e636f6d2f696d616765732f352e676966&quot; alt=&quot;pic&quot; data-canonical-src=&quot;http://staticonsae.sinaapp.com/images/5.gif&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;


&lt;/article&gt;

</content>
   </entry>
   
   <entry>
     <title>12小时——我的第二个创业项目</title>
     <link href="http://beiyuu.com/blog/2015/04/18/p12.html"/>
     <updated>2015-04-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/18/p12</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;一个好汉三个帮，一个良好的团队是成功的关键，产品，运营，推广，缺一不可。&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;app&quot;&gt;app简介&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;app 下载地址 &lt;a href=&quot;https://appsto.re/cn/JK764.i&quot;&gt;12小时&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;团队成员：一个ios开发 + 一个后台 ＋ 一个美术 ＋ 一个CEO&lt;/li&gt;
  &lt;li&gt;社交型的应用，主要功能有2点
    &lt;ol&gt;
      &lt;li&gt;限时聊天，晚上18：00开始，到第二天早上6点结束，然后数据全部清空。&lt;/li&gt;
      &lt;li&gt;群组功能，每天有2-10个群组可供选择，不同群组间没有交互。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;感想&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;再小的团队也需要teambitious这样的工具来做辅助管理&lt;/strong&gt;&lt;br /&gt;
一开始的时候我们就建立了一个群，每天有什么工作或者其他需求的改动就在群里说一下，不过越来越多的需求和越来越大的工作量使得一个QQ群根本就没办法处理。
从提需求要做修改再到测试验证，还有各种其他不可预测的因素。&lt;br /&gt;
一个敏捷开发的工具真的是能给团队带来很大的帮助。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一个产品需要一个产品经理&lt;/strong&gt;&lt;br /&gt;
就这个产品而言，前后台的交互以及美术的切图，还有测试的时候发现的各种bug，这些都是属于交接过程中的事情。&lt;br /&gt;
我作为ios开发攻城师，自然是前后端交互文档我来写，美术给我的psd我来切，测试发现了bug和我说，然后我再找原因fix。我就自然而然的担当起了产品经理这个角色。
    &lt;ul&gt;
      &lt;li&gt;美术是个刚毕业的大学生，没有很多的移动端的开发经验，给的psd有一部分是没有办法移植到手机客户端上边的。&lt;br /&gt;
切图就更加不用说了，代码实现的不同导致了切图的不同，最后基本就是美术给我个psd然后我切图修改。 &lt;br /&gt;
还有一些按钮需要一个highlight的状态，也都是我自己操作这ps慢慢画的。&lt;/li&gt;
      &lt;li&gt;后端的工程师以前做的是网页的后端，没有做过移动端的开发，以至于交互存在各种格式上的问题。&lt;br /&gt;
比如图片存储的接口调试了很久都没有办法成功，于是我就干脆用了七牛的图片存储。&lt;br /&gt;
ios中有写自带的表情（比如😊)是没办法在utf-8下找到对应的字符显示的，于是我们就参照百度贴吧(版本6.5.0)，把这些字符给过滤掉。&lt;br /&gt;
还有即时聊天socket和苹果的推送功能，我就用了一个第三方库，自己参照着写着js慢慢调试。&lt;/li&gt;
      &lt;li&gt;从一个产品的开始到提交app store也是我第一次的经理。之前都是跟着其他人做或者和其他人一起做，不会的可以问，现在只能百度谷歌。&lt;br /&gt;
在开发过程中还会遇到各种没有遇到以及没有预见的问题，可以说真的是鸭梨山大。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;团队很重要，甚至比产品还重要&lt;/strong&gt; &lt;br /&gt;
有的团队一个计划书就拿了100w的投资，有的团队demo出来了就能天使轮了。 &lt;br /&gt;
我们的CEO在产品appstore上架了依然没有融到资，他说他的前期费用是自己出的。 &lt;br /&gt;
我是每个月拿少量的生活费兼职做的，美术是拿工资全职，那个后台是没任何收入的兼职的。 &lt;br /&gt;
CEO是这么和我说的，不管他说的是真是假。我们在历经了4个月，从开始到appstore上线，每个人都付出了很多，最后却还没融到资，可以说每个人都有责任。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;前期的准备工作要做充分 &lt;br /&gt;&lt;/strong&gt;
就我ios而言，我原本以为第一个版本会很简单，只做了简单的架构，结果却发现内容还是比较多的，就第三方开源代码就用了14个，和后台的接口文档更是写了9页之多。&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;产品上线后的假数据 &lt;br /&gt;&lt;/strong&gt;
我们的产品上appstore上后，除去我们内部的人，先后一共有近50人安装过这个app，可是七日留存率是零，这个结果也是无可厚非的。&lt;br /&gt;
我们也没有重视这一块，再加上没有运营和推广，用户进去了，没有见到想见的美女帅哥，所以删应用也是很理所当然的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;后话&lt;/h2&gt;
&lt;p&gt;从项目开始到现在已经过去了半年左右了，我也和CEO提出了退出的申请。虽然他一再挽留，但是，我还是坚持我的决定。(美工是在做了一个月左右就离开了)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原因主要还是融资的问题，暂且不说产品的原因，appsotre上线了还是融资不到，我觉得对于大部分创业者来说都是无法接受的。&lt;/li&gt;
  &lt;li&gt;其次，我们可以算是一个草根的创业团队，就我一个是移动端开发的，其他都是半路出道转移动端的，对我来说，真的是鸭梨山大啊。&lt;/li&gt;
  &lt;li&gt;我们团队缺少运营，产品上线了基本就无从下手，不知从何开始推广，大家都没有经验，试着去QQ群或者贴吧里拉人，根本就杯水车薪。&lt;/li&gt;
  &lt;li&gt;虽然这个项目是基本失败了，但是我学到的东西还是很多的，不仅是ios技术的提升，还有简单js的入门，还认识到了整个项目的架构的重要性。
我不善言辞，只有经历了才能体会的到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;

&lt;p&gt;总之，对次的创业我感觉我也成长了不，我也认识到了并不是一两个程序员就能搞定的，产品做出来了，还需要运营以及推广，团队是最重要的。  &lt;br /&gt;
创业真的是很艰苦的，九死一生一点都不夸张。&lt;/p&gt;

&lt;!-- 连接 --&gt;

</content>
   </entry>
   
   <entry>
     <title>几乎整个互联网行业都缺 CTO【转】</title>
     <link href="http://beiyuu.com/blog/2015/04/10/%E5%87%A0%E4%B9%8E%E6%95%B4%E4%B8%AA%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A%E9%83%BD%E7%BC%BA%20CTO.html"/>
     <updated>2015-04-10T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/10/几乎整个互联网行业都缺 CTO</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.niaogebiji.com/article-6557-1.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.niaogebiji.com/article-6557-1.html&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;tbody&gt;&lt;tr&gt;&lt;td id=&quot;article_content&quot;&gt;&lt;div&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;几乎整个互联网行业都缺 CTO，特别是一些草根背景的创业者，这个问题更加显著。从我自己的感受，身边各种朋友委托我找 CTO 的需求，嗯，算下来超过两位数了，光最近一个月就有 3 个，而且这三家都是刚拿了 A 轮的。其他那些公司 CTO 大部分空缺了一两年，或者其他高管临时暂代过渡。实话说，我觉得每个公司都不错的，但通常也只能遗憾的说，真没有能推荐的。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;其实，根据个人的观察，每个互联网团队都喊需要 CTO，但是具体诉求却各不相同，如果说共性，就只有一点，那就是，公司老板对技术的期望值与目前技术团队的能力表现，有较大的差异，而这个差异，对于老板来说，就是一个想法，找个合格的 CTO，一切就都解决了。其实，真不是这回事。&lt;/div&gt;&lt;div&gt;&lt;b&gt;今天要说的第一点，就是期望值的控制&lt;/b&gt;&lt;/div&gt;&lt;div&gt;很多互联网公司都希望自己走技术驱动的路线，期望小而美，复制美国技术新贵的市场表现；这不能说是一个错误的期望，但是，现实能有多少符合这种需求的人才呢？这样的人才需要技术有前瞻性，对产业格局有判断，对管理有心得，情商还不能低（算了一下，四项里我至少三项不符合。）。整个行业内这样的人有几个？凭什么会跟你？事实上我身边确实有这样的案例，一个以业务为主的公司，搞定了一个超棒的 CTO，很快就转型成以技术为驱动的公司，公司价值极大提升，问题是，这种现象很难具有复制性。&lt;/div&gt;&lt;div&gt;&lt;b&gt;下面我说一下一个最基本的让人纠结的问题，到底什么是 CTO？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;其实，空谈这个名词的定义毫无意义，从我身边很多朋友公司的实例来看，他们对这个角色的定义和定位是差异非常大的。具体而言，不同创业团队，对 CTO 需求的真实想法，包括如下层面。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;font size=&quot;4&quot;&gt;技术选型&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;这其实是创业公司最纠结的问题；他们往往一上来基于已有的程序员的个人习惯和爱好，选择了一个技术方案，然后到某一天一看，我靠，全是坑（当然，也可能与执行者的能力有关）。而更糟的是，这个技术方案相对冷门，市场上去招聘都很难做。还有就是技术方案成本过高，（不只是钱的问题，特别是时间成本！）结果严重影响到后续的发展速度。　我举个简单例子，最近我给多个创业者提建议，比如做 app，很多以内容运营为核心的 app，不要用原生态开发，目前一堆第三方的跨平台开发架构，如果选择合适，可以极大减少开发成本，以及降低技术招聘的难度。微信开店开社区，也有一堆第三方平台，这些事情，对于一些创业者来说，就是特纠结的事情，第一，他们并不完全了解这个领域；第二，他们就算有所了解，也很难判断究竟谁家的方案更靠谱？难道要靠百度竞价排名来裁决么？　而对于技术人员，包括相当多技术高手，他们也会有一些自己的打算，比如说，我就熟悉这个，为啥要用2我不熟悉的？（没有考虑从公司长远的人力成本和开发效率）。比如说，我本来服务端技术很强，现在用了一个开源服务端框架，比如 skynet，我变成写脚本的了，我价值怎么体现？（不知道自己的价值来自于产品的市场表现）。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;font size=&quot;4&quot;&gt;&lt;b&gt;万能适配器&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;公司有了一个基本的起步，比如在某个平台上有了一点成绩，然后希望扩展到不同领域，不同平台，然后老板突然发现，哦，原来程序员不是什么都会的。服务端，前端，运维，安全，数据库，甚至 SEO 优化（你敢说这不是技术？）最好有个牛人都能带起来，这个牛人，就是他们定义的 CTO，咳咳。创业公司，人少而事杂，其实，真的可以理解。我认识不少创业者，最终万般无奈下，硬是把自己逼成了万能哥。话说当年我也是创业的时候，万般无奈才自学怎么做运维的，虽然很多都没学会，但是偶尔也能出去忽悠一下。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;font size=&quot;4&quot;&gt;&lt;b&gt;性能调优及架构扩展&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;很多小公司到了一定的用户规模和并发规模的时候，一下子就扛不住了，甚至严重影响业务的拓展，某著名淘品牌自己做了一个独立网店，结果一搞秒杀活动就崩溃，（吐个槽，他们运营人员也死心眼，就知道搞秒杀，知道技术架构不行，不会搞点别的形式么）。结果独立网店一直就没搞起来。其实很多这些偏传统的互联网公司，他们所遇到的问题，在高手眼里不值一提，但是这个坎过不去，他们真就发展不起来。说个题外话八卦一下，当年腾讯叫OICQ的时候，一堆 *icq，只有腾讯牛了，其他的为啥不行？真的是产品原因么？其实都是这个问题，到了１００万用户的时候，就只有腾讯还能发展新用户，其他的技术全都撑不住了。大家看到的都是剩者为王，我看到的是，数不清非常不错的产品，死在这个环节上了。严格的说，这其实不是 CTO 的工作，按照分工来说，通常涉及系统分析师，系统架构师，以及 DBA 来做这方面的工作，但是对于创业公司，根本就没这种角色设定，他们遇到这个问题，通常想到的是，有个好的 CTO 就好了。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;font size=&quot;4&quot;&gt;&lt;b&gt;团队管理和效率提升，这还真是 CTO 的本职工作了&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;我遇到技术出身的创业者，他纠结的问题是，当时自己一个人做开发，连带着做运营，七七八八一堆事，也把东西做起来了，现在公司产品知名度有了，拿到投资了，开发团队也搭起来了，怎么开发效率反而下去了？所以，他的理解是，需要一个 CTO。　从技术人才招聘，团队培养，技术培训，到开发模式培训（比如现在流行的敏捷开发），产品质量测评体系，信息安全防护等等，这些林林总总的事情，对于创业者来说，就全部归纳为“需要一个 CTO”，嗯。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;font size=&quot;4&quot;&gt;&lt;b&gt;数据决策体系&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;自从“大数据”概念火了以后，基本上所有创业者都在谈，我的业务模式，发展了海量用户后，一定是基于数据驱动，可是数据咋驱动？没几个人真想清楚了，但是没关系，只要有 CTO，这个问题就解决了。　我知道真有能搞定此事的 CTO，真的有，不过，真的属于稀缺品种，目测比大熊猫还少。因为，要理解数据驱动，首先要理解业务，而理解业务，往往不是技术人员的特长。又要自吹一句，我在百度的时候，最牛逼的事情就是在产品部门里搭出一个技术团队，来做数据，为什么要坚持在产品部门编制？（实话说，当年技术部门的薪酬更高一些），我坚持认为重心在于数据目标和解读，而不是技术实现。　所以，这里我多说一句，数据决策体系，先想清楚具体目标和具体展现，再寻求技术支持，而不是一句话推给技术团队去弄，除非你公司里真有这么一只极品稀缺大熊猫。　实际上，再吐个槽，最基本的数据处理的结果，经过正确严谨的解读，就已经有极大的价值了，而很多人往往无视这些，去追求更高深的技术实现，搞一些莫名其妙的算法和逻辑，来彰显技术价值，其实是舍近求远的表现。　&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;font size=&quot;4&quot;&gt;&lt;b&gt;重构商业模式&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;这个，咳咳，怎么说呢，公司觉得自己商业模式不够酷，不够吸引资本关注，希望从业务驱动转为技术驱动，嗯，来个牛逼的 CTO，这事真可行，嗯，话说，这事真可行，点到为止，不展开了。　&lt;/div&gt;&lt;div&gt;以上是我观测到的，身边以及业内一些典型的 CTO 需求，当然，不同公司诉求真的不一样。有的侧重管理，有的侧重解决瓶颈问题，但是对老板而言，只要他们认为目前技术团队不够好，不够给力，不够预期，那么，这就是他们认为缺乏的，CTO。不仅仅是创业公司，上市公司乃至巨头，这个问题也一样存在，比如说，百度的 CTO，貌似空缺了好几年呢。是他们的人才不够优秀么？还不是达不到李厂长期望值。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;下面说我的一些观点&lt;/div&gt;&lt;div&gt;&lt;b&gt;第一、&lt;/b&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;相当比例大公司背景的技术牛人，并不适合去创业公司做 CTO，原因&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;1：技术再牛，不够全面，这没辙，大公司求深，创业公司求全&lt;/div&gt;&lt;div&gt;2：技术再牛，要懂业务。&lt;/div&gt;&lt;div&gt;创业公司没有完备严谨的产品经理，没有明确的目标规划，很多工作是一个初步的目标，然后做起来看。如果技术人员不懂业务，很可能就会走弯路，做出很多不伦不类的东西，所以创业公司遇到这样的大牛，要先沟通到位再决定，不要迷信简历，当然，不乏这里有非常出色的。&lt;/div&gt;&lt;div&gt;&lt;b&gt;第二、&lt;/b&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;创始公司老板要想清楚自己当前真正需要的是什么，控制一下目标和欲望，有些事不能强求的&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第三、&lt;/b&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;要给人才成长的空间，CTO 也不是天生的，不要认为外面的和尚一定好念经。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;第四、&lt;/b&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;遇到真的特别合适的人才，要舍得本钱，理想可以谈，但是让人家舍弃各种丰厚回报的机会来跟你打拼，总要出示一些诚意。要知道这样的人才是稀缺品。&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;line-height: 1.8em;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;最后解释一下 CTO 所需要的四个领域的能力&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;技术前瞻性&lt;/b&gt;&lt;/div&gt;&lt;div&gt;就好比 2010 年谷歌手机发布了，您还在那里吭哧吭哧跟老板说咱们好好弄塞班。（好多技术牛人，大公司的技术总监都是这样的！！！）。&lt;/div&gt;&lt;div&gt;&lt;b&gt;对产业格局有判断&lt;/b&gt;&lt;/div&gt;&lt;div&gt;举例来说，移动互联网起来了，能知道工具型，娱乐性，生活性的应用大概的爆发周期和爆发规模。 能对移动游戏，电商的发展速度和市场顶点在哪里，这样才能给老板正确的技术投入建议和规划目标建议，别市场喷发的时候不去考虑准备架构扩容，还在角落里扣扣索索的算怎么比同行省点运维成本。&lt;/div&gt;&lt;div&gt;&lt;b&gt;管理心得&lt;/b&gt;&lt;/div&gt;&lt;div&gt;技术团队的培养和带动，别光顾着自己牛逼，要让团队牛逼。&lt;/div&gt;&lt;div&gt;&lt;b&gt;情商&lt;/b&gt;&lt;/div&gt;&lt;div&gt;各种沟通，协调，不解释。&lt;/div&gt;&lt;div&gt;就这样，有点凌乱，凑活看吧。&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;

</content>
   </entry>
   
   <entry>
     <title>apple watch 预言</title>
     <link href="http://beiyuu.com/blog/2015/04/07/applewatch.html"/>
     <updated>2015-04-07T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/07/applewatch</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;今天是4.7，离4.10还有3天。
&lt;br /&gt;
我预言apple watch会火，至少不会死。
&lt;br /&gt;
鄙视网上各种说了一大堆理由而不做结论的文章。&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;转一片36kr的文章:  &lt;a href=&quot;http://36kr.com/p/531427.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;为什么说苹果表一定会死&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;section class=&quot;single-post-header&quot;&gt;&lt;div class=&quot;single-post-header__headline&quot;&gt;&lt;img alt=&quot;&quot; class=&quot;image&quot; height=&quot;337&quot; src=&quot;http://a.36krcnd.com/nil_class/583f3b46-7028-4ab0-a559-da0a382c8633.jpg&quot; width=&quot;620&quot; /&gt;&lt;/div&gt;&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么说苹果表一定会死&lt;/h2&gt;

&lt;section class=&quot;article&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;苹果表发布也有段时间了，而关于这块表到底如何也一直争论不休：正方从各个角度去说这块手表如何如何不好，什么性能低下续航垃圾一块电子表也好意思挑战奢侈表；而反方举起自己的大旗帜，拿出当年骂iPhone的诺基亚的下场，拿出当年骂iPad的人的ID，再拿出初代的苹果电脑ebay上的拍卖价格，高喊着你们这帮胆敢阻碍历史前进，可穿戴时代来临的蛆虫，一定会被碾得粉碎……&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是，我仍要说，这款手表是个垃圾，它注定失败。可穿戴时代，不是苹果这种保守表能够带领起来的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然，不列论据就是耍流氓。接下来就来看看，为什么这款手表注定失败。&lt;/p&gt;&lt;p&gt;不过在看失败之前，我们先来看看  iPhone 和iPad 为什么成功了。&lt;/p&gt;&lt;p&gt;其实，我觉得  iPhone 时代和  iPad 时代，对着苹果唱反调的都是属于科技宅、各种技术行家，事实上那个时候，普通民众并不关心苹果也不关注苹果，那时苹果的品牌影响力相比今天差得太远。在那个时代，苹果的哲学是如何把人们每天要用的东西做到极致，而不是像技术专家们那样，自己有什么需求就打造一个东西把那个专门需求完全满足。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而手机，则正是人们一定要用的东西。假设当年没有苹果，今天一样会人手一部手机，即便一直停留在诺基亚智能机时代。这个，你可以直接去看看手机市场在  iPhone 之前的发展幅度就能很清楚。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果，要做的并不是创造不存在的东西，而是在已经相对成熟的手机市场里给人们选择它的理由。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果给出的答案就是轻娱乐。&lt;/p&gt;&lt;p&gt;如今的地铁上，放眼望去，人们拿着手机就是看视频、看小说、玩游戏。所有的东西都可以碎片化轻度化，随时抽离，无聊时又能回来。人们不需要engagement，不需要强烈的沉浸感代入感，人们不想在公众面前展示自己真实的体验感受，只希望能够默默地装逼，一边看着自己的手机，斜眼看着旁边的人在玩啥。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;我记得我刚上大学时候，对手机完全没有兴趣，满脑子想的都是新的mp4。经常上中关村在线看新的mp4新闻，看着哪款蓝魔台电mp4又支持了哪种新的视频格式，是不是支持pdf，一如你们今天刷36氪。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而我的舍友看手机，后来还买了个psp。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;于那时的我而言，我觉得能随时随地看视频是再幸福不过的事；听歌是基本要求，至于游戏我主要玩PC游戏所以psp这种看起来很复杂的东西我就没关注过。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是，那时的我们都已经在渴求着有一个能够随身携带、消除坐车无聊的个人娱乐中心，我是视频和图书，而我舍友是游戏。对于在大城市成天上下班赶地铁的人来说，这是绝对的刚需。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;然后，iPhone 就是满足了这些刚需，把这些每个人都希望有的功能整合到了一起。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;没错，就是每个人都希望有的功能  – 因为这些功能没有学习门槛，我们从小就知道它们是娱乐。证据就是，为了随时看视频出现了mp4这种产品，为了随身玩游戏出现了psp、3ds这种产品，为了看电子书，即便是后来居上的kindle都竟然又从ipad手中分走了一片江山。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;iPhone在那个时代把这些功能都整合到一起，带来了整个移动互联网的兴起，这几乎是必然的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然，更大的争议是在  iPad 上。iPad 其实就是  iPhone 娱乐功能的升级版。即便是在mp4时代，我们已经在关注mp4的屏幕尺寸大小，因此初代的iPhone就屏幕本身肯定是满足不了那些天天消费视频、电子书和游戏的人的。iPad 为的就是满足这个。而手机越来越大，现在基本稳定在5-6寸之间，原因其实就是便携性和看视频、看书体验平衡的一个甜点而已，一旦满足之后，大家发现也懒得拿起  iPad 了。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这两款产品，成功得如此轻松而又必然，实际上也一点不出人意料。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;但是这款苹果表，是完全没有以上属性的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;让我们慢慢来  – 首先，这是一块手表吗？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然不是，关于这个话题争论得已经比较清楚了，手表本身的功能  – 看时间早就没有了，现在的传统手表代表的是身份地位，或者说  – 情怀，不可能被这种廉价的电子表所撼动，尤其在电子产品必须一年一换的前提下。当然，有人提到苹果表能让年轻人和中年人在身份地位的对拼中转换战场。这是个有意思的提法，不过现实中影响不大。的确，当你和富豪接触多了你会发现对于电子产品他们大多没有什么敏感度，倒不是因为他们是土豪，而是因为他们生活中有太多东西值得关注，而不是这种电子产品。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那么，这到底是什么呢？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;它只有一个定位可以走：成为一个个人中心。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;戴在手上，随时跟踪你的一举一动，知道你的位置，知道你的状态，你的身体健康，同时提供服务……一个健康向上的科幻未来设想中的美好道具。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;除了，它一点用也没有已。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;我们来看看：目前苹果表续航只有6个小时。一天一冲是必然的。当然，我们相信技术的演变，说不定哪天电池技术大革命，或者无线充电WIFI化，这都不是问题。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那我们再看看更重要的：现在苹果官方建议每个app一次让人的浏览时间不超过10秒。这能干什么？这样的话我在旅途中，还是得掏出手机/平板来解决无聊问题。嗯，没关系，我们假设苹果逆天，手表未来带投影功能（那么我们在地铁上就为面积打架了）。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而作为个人中心，不可否认取代银行卡/公交卡等等还是非常方便的，这也是我觉得手环这种奇葩设备唯一可能有用的点 – 而这个关键更大的推动层面会在政府，而非个人。不过，这些东西，手机上也一定都会有。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;因此，关键点之一来了：我们把苹果表和手机一对比，发现了在个人中心这个定义下的一些尴尬竞争：在目前科技方面的任何创意和应用，如果能放到手表上，在手机上绝对会先出现。比如说，各种取代银行卡的应用/支付系统，各种监控身体状况的传感器/计步器，这些都会先在手机上进行试水。这并不光光是看这个功能合适不合适的问题，而是手机厂商处于创新压力下，必然会做的事情。而作为个人中心，很重要的是和人的亲近感，手机早已不是问题，手表看起来离人更近，但这点差距对于如今的产品路线来说已经造不成什么影响。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;表能得到的研发资源，很难超过手机 – 那么多大厂需要靠手机活，但现在除了 Pebble 这种就是要踏可穿戴热潮的初创企业，没有几个厂是靠电子表活的。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这就直接意味着，在个人中心这个层面，手表很难取代手机。电子设备这条路上，手机将还是会占据第一考虑位置，而不是手表。如果你要添置电子产品，你首先考虑的是手机，然后可能是平板/笔记本/个人台式，最后无聊了就是钱多任性了才会是手表。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;那我们如果假设手机和手表在技术方面齐头并进，一直到手机的功能早就过剩，而手表终于能满足人的日常使用了，那么表是不是就翻身农奴当家了呢？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;当然不是，反而  – 到了这一天，它的末日就基本来了。&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;假设有一天，在一块手表的 Form factor 里，我们也能满足我们日常的一切需求，能投影看视频，能社交，玩游戏，放ppt，甚至编辑文档视频，毫无担心续航问题……&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;这个时候我们会问的是，一个智能眼镜能干什么？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;AR/VR 必将成为众人眼中的未来。那个时候，我们天天追逐的对象，必须就是新款的眼镜  -想想，微软最终的 Hololens 和同年发布的苹果表摆在你面前，你要哪个？&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;而苹果表，也只能放在角落里搓灰了吧。&lt;/p&gt;&lt;/section&gt;

</content>
   </entry>
   
   <entry>
     <title>abc</title>
     <link href="http://beiyuu.com/mine/2015/04/04/sylarCV.html"/>
     <updated>2015-04-04T00:00:00+08:00</updated>
     <id>http://beiyuu.com/mine/2015/04/04/sylarCV</id>
     <content type="html">
</content>
   </entry>
   
   <entry>
     <title>理解 Objective-C Runtime【转】</title>
     <link href="http://beiyuu.com/blog/2015/04/02/runtime.html"/>
     <updated>2015-04-02T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/04/02/runtime</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20141008/9844.html&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.cocoachina.com/ios/20141008/9844.html&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;entry-content&quot;&gt;

&lt;p&gt;初学 Objective-C(以下简称ObjC) 的人很容易忽略一个 ObjC 特性 —— ObjC Runtime。这是因为这门语言很容易上手，几个小时就能学会怎么使用，所以程序员们往往会把时间都花在了解 Cocoa 框架以及调整自己的程序的表现上。然而 Runtime 应该是每一个 ObjC 都应该要了解的东西，至少要理解编译器会把&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[target doMethodWith:var1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(target,@selector(doMethodWith:),var1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的语句。理解 ObjC Runtime 的工作原理，有助于你更深入地去理解 ObjC 这门语言，理解你的 App 是怎样跑起来的。我想所有的 Mac/iPhone 开发者，无论水平如何，都会从中获益的。&lt;/p&gt;
&lt;h2&gt;ObjC Runtime 是开源的&lt;/h2&gt;
&lt;p&gt;ObjC Runtime 的代码是开源的，可以从这个站点下载： &lt;a href=&quot;http://opensource.apple.com/&quot;&gt;opensource.apple.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个是所有开源代码的链接： &lt;a href=&quot;http://www.opensource.apple.com/source/&quot;&gt;http://www.opensource.apple.com/source/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是ObjC rumtime 的源代码: &lt;a href=&quot;http://www.opensource.apple.com/source/objc4/&quot;&gt;http://www.opensource.apple.com/source/objc4/&lt;/a&gt;&lt;br /&gt;
4应该代表的是build版本而不是语言版本，现在是ObjC 2.0&lt;/p&gt;
&lt;h2&gt;动态 vs 静态语言&lt;/h2&gt;
&lt;p&gt;ObjC 是一种面向runtime(运行时)的语言，也就是说，它会尽可能地把代码执行的决策从编译和链接的时候，推迟到运行时。这给程序员写代码带来很大的灵活性，比如说你可以把消息转发给你想要的对象，或者随意交换一个方法的实现之类的。这就要求 runtime 能检测一个对象是否能对一个方法进行响应，然后再把这个方法分发到对应的对象去。我们拿 C 来跟 ObjC 对比一下。在 C 语言里面，一切从 main 函数开始，程序员写代码的时候是自上而下地，一个 C 的结构体或者说类吧，是不能把方法调用转发给其他对象的。举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt; stdio.h &amp;gt;

int main(int argc, const char **argv[])
{
        printf(&quot;Hello World!&quot;);
        return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码被编译器解析，优化后，会变成一堆汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.text
 .align 4,0x90
 .globl _main
_main:
Leh_func_begin1:
 pushq %rbp
Llabel1:
 movq %rsp, %rbp
Llabel2:
 subq $16, %rsp
Llabel3:
 movq %rsi, %rax
 movl %edi, %ecx
 movl %ecx, -8(%rbp)
 movq %rax, -16(%rbp)
 xorb %al, %al
 leaq LC(%rip), %rcx
 movq %rcx, %rdi
 call _printf
 movl $0, -4(%rbp)
 movl -4(%rbp), %eax
 addq $16, %rsp
 popq %rbp
 ret
Leh_func_end1:
 .cstring
LC:
 .asciz &quot;Hello World!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，再链接 include 的库，完了生成可执行代码。对比一下 ObjC，当我们初学这门语言的时候教程是这么说滴：用中括号括起来的语句，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self doSomethingWithVar:var1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;被编译器编译之后会变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(self,@selector(doSomethingWithVar:),var1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个 C 方法，传入了三个变量，self指针，要执行的方法 @selector(doSomethingWithVar:) 还有一个参数 var1。但是在这之后就不晓得发生什么了。&lt;/p&gt;
&lt;h2&gt;什么是 Objective-C Runtime?&lt;/h2&gt;
&lt;p&gt;ObjC Runtime 其实是一个 Runtime 库，基本上用 C 和汇编写的，这个库使得 C 语言有了面向对象的能力（脑中浮现当你乔帮主参观了施乐帕克的 SmallTalk 之后嘴角一抹浅笑）。这个库做的事前就是加载类的信息，进行方法的分发和转发之类的。&lt;/p&gt;
&lt;h2&gt;Objective-C Runtime 术语&lt;/h2&gt;
&lt;p&gt;再往下深谈之前咱先介绍几个术语。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 Runtimes
&lt;p&gt;目前说来Runtime有两种，一个 Modern Runtime 和一个 Legacy Runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2 Basic types of Methods
&lt;p&gt;一种 Instance Method，还有 Class Method。instance method 就是带“-”号的，需要实例化才能用的，如 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(void)doFoo; 

[aObj doFoot];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class Method 就是带“+”号的，类似于静态方法可以直接调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(id)alloc;

[ClassName alloc];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些方法跟 C 函数一样，就是一组代码，完成一个比较小的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(NSString *)movieTitle
{
    return @&quot;Futurama: Into the Wild Green Yonder&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Selector
&lt;p&gt;一个 Selector 事实上是一个 C 的结构体，表示的是一个方法。定义是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_selector  *SEL; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用起来就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SEL aSel = @selector(movieTitle); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样可以直接取一个selector，如果是传递消息（类似于C的方法调用）就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[target getMovieTitleForObject:obj];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 ObjC 里面，用&#39;[]’括起来的表达式就是一个消息。包括了一个 target，就是要接收消息的对象，一个要被调用的方法还有一些你要传递的参数。类似于 C 函数的调用，但是又有所不同。事实上上面这个语句你仅仅是传递了 ObjC 消息，并不代表它就会一定被执行。target 这个对象会检测是谁发起的这个请求，然后决策是要执行这个方法还是其他方法，或者转发给其他的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Class
&lt;p&gt;Class 的定义是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct objc_class *Class;
typedef struct objc_object {
    Class isa;
} *id; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到这里这里有两个结构体，一个类结构体一个对象结构体。所有的 objc_object 对象结构体都有一个 isa 指针，这个 isa 指向它所属的类，在运行时就靠这个指针来检测这个对象是否可以响应一个 selector。完了我们看到最后有一个 id 指针。这个指针其实就只是用来代表一个 ObjC 对象，有点类似于 C++ 的泛型。当你拿到一个 id 指针之后，就可以获取这个对象的类，并且可以检测其是否响应一个 selector。这就是对一个 delegate 常用的调用方式啦。这样说还有点抽象，我们看看 LLVM/Clang 的文档对 Blocks 的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; struct Block_literal_1 {
    void *isa; // initialized to &amp;amp;_NSConcreteStackBlock or &amp;amp;_NSConcreteGlobalBlock
    int flags;
    int reserved; 
    void (*invoke)(void *, ...);
    struct Block_descriptor_1 {
 unsigned long int reserved; // NULL
     unsigned long int size;  // sizeof(struct Block_literal_1)
 // optional helper functions
     void (*copy_helper)(void *dst, void *src);
     void (*dispose_helper)(void *src); 
    } *descriptor;
    // imported variables
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到一个 block 是被设计成一个对象的，拥有一个 isa 指针，所以你可以对一个 block 使用 retain, release, copy 这些方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;IMP (Method Implementations)
&lt;p&gt;接下来看看啥是IMP。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef id (*IMP)(id self,SEL _cmd,...); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个 IMP 就是一个函数指针，这是由编译器生成的，当你发起一个 ObjC 消息之后，最终它会执行的那个代码，就是由这个函数指针指定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Objective-C Classes
&lt;p&gt;OK，回过头来看看一个 ObjC 的类。举一个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface MyClass : NSObject {
//vars
NSInteger counter;
}
//methods
-(void)doFoo;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义一个类我们可以写成如上代码，而在运行时，一个类就不仅仅是上面看到的这些东西了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到运行时一个类还关联了它的父类指针，类名，成员变量，方法，cache 还有附属的 protocol。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;那么类定义了对象并且自己也是个对象？这是咋整滴？&lt;/h2&gt;
&lt;p&gt;上面我提到过一个 ObjC 类同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做 &lt;del&gt;标签类&lt;/del&gt; 元类（Meta Class）的东西。当你发出一个消息的时候，比方说&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[NSObject alloc];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你事实上是把这个消息发给了一个类对象（Class Object），这个类对象必须是一个 Meta Class 的实例，而这个 Meta Class 同时也是一个根 MetaClass 的实例。当你继承了 NSObject 成为其子类的时候，你的类指针就会指向 NSObject 为其父类。但是 Meta Class 不太一样，所有的 Meta Class 都指向根 Meta Class 为其父类。一个 Meta Class 持有所有能响应的方法。所以当 [NSObject alloc] 这条消息发出的时候，objc_msgSend() 这个方法会去 NSObject 它的 Meta Class 里面去查找是否有响应这个 selector 的方法，然后对 NSObject 这个类对象执行方法调用。&lt;/p&gt;
&lt;h2&gt;为啥我们要继承 Apple Classes&lt;/h2&gt;
&lt;p&gt;初学 Cocoa 开发的时候，多数教程都要我们继承一个类比方 NSObject，然后我们就开始 Coding 了。比方说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject *object = [[MyObject alloc] init];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语句用来初始化一个实例，类似于 C++ 的 new 关键字。这个语句首先会执行 MyObject 这个类的 +alloc 方法，Apple 的官方文档是这样说的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
  The isa instance variable of the new instance is initialized to a data structure that describes the class; memory for all other instance variables is set to 0.&lt;/p&gt;
&lt;p&gt;  新建的实例中，isa 成员变量会变初始化成一个数据结构体，用来描述所指向的类。其他的成员变量的内存会被置为0.
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以继承 Apple 的类我们不仅是获得了很多很好用的属性，而且也继承了这种内存分配的方法。&lt;/p&gt;
&lt;h2&gt;那么啥是 Class Cache(objc_cache *cache)&lt;/h2&gt;
&lt;p&gt;刚刚我们看到 runtime 里面有一个指针叫 objc_cache *cache，这是用来缓存方法调用的。现在我们知道一个实例对象被传递一个消息的时候，它会根据 isa 指针去查找能够响应这个消息的对象。但是实际上我们在用的时候，只有一部分方法是常用的，很多方法其实很少用或者根本用不到。比如一个object你可能从来都不用copy方法，那我要是每次调用的时候还去遍历一遍所有的方法那就太笨了。于是 cache 就应运而生了，每次你调用过一个方法，之后，这个方法就会被存到这个 cache 列表里面去，下次调用的时候 runtime 会优先去 cache 里面查找，提高了调用的效率。举一个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MyObject *obj = [[MyObject alloc] init]; // MyObject 的父类是 NSObject

@implementation MyObject
-(id)init {
    if(self = [super init]){
        [self setVarA:@”blah”];
    }
    return self;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码是这样执行的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[MyObject alloc] 先被执行。但是由于 MyObject 这个类没有 +alloc 这个方法，于是去父类 NSObject 查找。&lt;/li&gt;
&lt;li&gt;检测 NSObject 是否响应 +alloc 方法，发现响应，于是检测 MyObject 类，根据其所需的内存空间大小开始分配内存空间，然后把 isa 指针指向 MyObject 类。那么 +alloc 就被加进 cache 列表里面了。&lt;/li&gt;
&lt;li&gt;完了执行 -init 方法，因为 MyObject 响应该方法，直接加入 cache。&lt;/li&gt;
&lt;li&gt;执行 self = [super init] 语句。这里直接通过 super 关键字调用父类的 init 方法，确保父类初始化成功，然后再执行自己的初始化逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OK，这就是一个很简单的初始化过程，在 NSObject 类里面，alloc 和 init　没做什么特别重大的事情，但是，ObjC 特性允许你的 alloc 和 init 返回的值不同，也就是说，你可以在你的 init 函数里面做一些很复杂的初始化操作，但是返回出去一个简单的对象，这就隐藏了类的复杂性。再举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt; Foundation/Foundation.h&amp;gt;

@interface MyObject : NSObject
{
 NSString *aString;
}

@property(retain) NSString *aString;

@end

@implementation MyObject

-(id)init
{
 if (self = [super init]) {
  [self setAString:nil];
 }
 return self;
}

@synthesize aString;

@end



int main (int argc, const char * argv[]) {
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

 id obj1 = [NSMutableArray alloc];
 id obj2 = [[NSMutableArray alloc] init];

 id obj3 = [NSArray alloc];
 id obj4 = [[NSArray alloc] initWithObjects:@&quot;Hello&quot;,nil];

 NSLog(@&quot;obj1 class is %@&quot;,NSStringFromClass([obj1 class]));
 NSLog(@&quot;obj2 class is %@&quot;,NSStringFromClass([obj2 class]));

 NSLog(@&quot;obj3 class is %@&quot;,NSStringFromClass([obj3 class]));
 NSLog(@&quot;obj4 class is %@&quot;,NSStringFromClass([obj4 class]));

 id obj5 = [MyObject alloc];
 id obj6 = [[MyObject alloc] init];

 NSLog(@&quot;obj5 class is %@&quot;,NSStringFromClass([obj5 class]));
 NSLog(@&quot;obj6 class is %@&quot;,NSStringFromClass([obj6 class]));

 [pool drain];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你是ObjC的初学者，那么你很可能会认为这段代码执的输出会是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSMutableArray
NSMutableArray 
NSArray
NSArray
MyObject
MyObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但事实上是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj1 class is __NSPlaceholderArray
obj2 class is NSCFArray
obj3 class is __NSPlaceholderArray
obj4 class is NSCFArray
obj5 class is MyObject
obj6 class is MyObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为 ObjC 是允许运行 +alloc 返回一个特定的类，而 init 方法又返回一个不同的类的。可以看到 NSMutableArray 是对普通数组的封装，内部实现是复杂的，但是对外隐藏了复杂性。&lt;/p&gt;
&lt;h2&gt;OK说回 objc_msgSend 这个方法&lt;/h2&gt;
&lt;p&gt;这个方法做的事情不少，举个栗子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self printMessageWithString:@&quot;Hello World!&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句语句被编译成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_msgSend(self,@selector(printMessageWithString:),@&quot;Hello World!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法先去查找 self 这个对象或者其父类是否响应 @selector(printMessageWithString:)，如果从这个类的方法分发表或者 cache 里面找到了，就调用它对应的函数指针。如果找不到，那就会执行一些其他的东西。步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。&lt;/li&gt;
&lt;li&gt;检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。&lt;/li&gt;
&lt;li&gt;如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。&lt;/li&gt;
&lt;li&gt;如果 cache 找不到就找一下方法分发表。&lt;/li&gt;
&lt;li&gt;如果还找不到就要开始&lt;strong&gt;消息转发逻辑&lt;/strong&gt;了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在编译的时候，你定义的方法比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(int)doComputeWithNum:(int)aNum 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会编译成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后由 runtime 去调用指向你的这个方法的函数指针。那么之前我们说你发起消息其实不是对方法的直接调用，其实 Cocoa 还是提供了可以直接调用的方法的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 首先定义一个 C 语言的函数指针
int (computeNum *)(id,SEL,int);

// 使用 methodForSelector 方法获取对应与该 selector 的杉树指针，跟 objc_msgSend 方法拿到的是一样的
// **methodForSelector 这个方法是 Cocoa 提供的，不是 ObjC runtime 库提供的**
computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(doComputeWithNum:)];

// 现在可以直接调用该函数了，跟调用 C 函数是一样的
computeNum(obj,@selector(doComputeWithNum:),aNum); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你需要的话，你可以通过这种方式你来确保这个方法一定会被调用。&lt;/p&gt;
&lt;h2&gt;消息转发机制&lt;/h2&gt;
&lt;p&gt;在 ObjC 这门语言中，发送消息给一个并不响应这个方法的对象，是合法的，应该也是故意这么设计的。换句话说，我可以对任意一个对象传递任意一个消息（看起来有点像对任意一个类调用任意一个方法，当然事实上不是），当然如果最后找不到能调用的方法就会 Crash 掉。&lt;/p&gt;
&lt;p&gt;Apple 设计这种机制的原因之一就是——用来模拟多重继承（ObjC 原生是不支持多重继承的）。或者你希望把你的复杂设计隐藏起来。这种转发机制是 Runtime 非常重要的一个特性，大概的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找该类及其父类的 cahce 和方法分发表，在找不到的情况下执行2。&lt;/li&gt;
&lt;li&gt;执行 + (BOOL) resolveInstanceMethod:(SEL)aSEL 方法。
&lt;p&gt;这就给了程序员一次机会，可以告诉 runtime 在找不到改方法的情况下执行什么方法。举个栗子，先定义一个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void fooMethod(id obj, SEL _cmd)
{
 NSLog(@&quot;Doing Foo&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完了重载 resolveInstanceMethod 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)aSEL
{
    if(aSEL == @selector(doFoo:)){
        class_addMethod([self class],aSEL,(IMP)fooMethod,&quot;v@:&quot;);
        return YES;
    }
    return [super resolveInstanceMethod];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中  “v@:” 表示返回值和参数，这个符号涉及 Type Encoding，可以参考Apple的文档 &lt;a href=&quot;http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1&quot;&gt;ObjC Runtime Guide&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来 Runtime 会调用 – (id)forwardingTargetForSelector:(SEL)aSelector 方法。&lt;br /&gt;
这就给了程序员第二次机会，如果你没办法在自己的类里面找到替代方法，你就重载这个方法，然后把消息转给其他的Object。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
{
    if(aSelector == @selector(mysteriousMethod:)){
        return alternateObject;
    }
    return [super forwardingTargetForSelector:aSelector];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样你就可以把消息转给别人了。当然这里你不能 return self,不然就死循环了=.=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;最后，Runtime 会调用 – (void)forwardInvocation:(NSInvocation *)anInvocation  这个方法。NSInvocation 其实就是一条消息的封装。如果你能拿到 NSInvocation，那你就能修改这条消息的 target, selector 和 arguments。举个栗子：
&lt;pre&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation
{
    SEL invSEL = invocation.selector;

    if([altObject respondsToSelector:invSEL]) {
        [invocation invokeWithTarget:altObject];
    } else {
        [self doesNotRecognizeSelector:invSEL];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下 NSObject 对 forwardInvocation 的实现就是简单地执行 -doesNotRecognizeSelector: 这个方法，所以如果你想真正的在最后关头去转发消息你可以重载这个方法（好折腾-.-）。&lt;/p&gt;
&lt;p&gt;原文后面介绍了 Non Fragile ivars (Modern Runtime)， Objective-C Associated Objects 和 Hybrid vTable Dispatch。鉴于一是底层的可以不用理会，一是早司空见惯的不用详谈，还有一个是很简单的，就是一个建立在方法分发表里面填入默认常用的 method，所以有兴趣的读者可以自行查阅原文，这里就不详谈鸟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&quot;&gt;Objective-C Runtime Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html&quot;&gt;Objective-C Runtime Reference&lt;/a&gt;&lt;/p&gt;
					&lt;/div&gt;
</content>
   </entry>
   
   <entry>
     <title>小白学ruby【基本语法持续更新中】</title>
     <link href="http://beiyuu.com/blog/2015/03/24/%E5%B0%8F%E7%99%BD%E5%AD%A6ruby.html"/>
     <updated>2015-03-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/24/小白学ruby</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;本人从2012年开始学习ios，现在开始学习ruby，记录下学习过程中遇到的各种坑（个人分享经验，仅供参考）...
&lt;br /&gt;
转载请声明出处:  &lt;a href=&quot;http://sylarcao.github.io/blog/2015/03/24/%E5%B0%8F%E7%99%BD%E5%AD%A6ruby.html&quot;&gt;本文转自sylar的博客&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;ruby---&quot;&gt;ruby - 竟然没有函数重载&lt;/h2&gt;
&lt;ol style=&quot; margin-bottom: 8px; &quot;&gt;我以为有的，此处省略我被坑了34次……&lt;/ol&gt;
&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;参考连接:  &lt;a href=&quot;http://dtzq01.iteye.com/blog/1010557&quot;&gt;http://dtzq01.iteye.com/blog/1010557&lt;/a&gt;
&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;ruby---random&quot;&gt;ruby - random数字&lt;/h2&gt;
&lt;scomment&gt;# 随机一个 0-9 的数字&lt;/scomment&gt;
&lt;p&gt;&lt;code&gt;random_number = Random.rand (10)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;ruby---for-&quot;&gt;ruby - for 循环&lt;/h2&gt;
&lt;scomment&gt; # for loop [1,10)   &lt;/scomment&gt;
&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;scomment&gt; # http://www.tutorialspoint.com/ruby/ruby_loops.htm &lt;/scomment&gt;

&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt; for i in 1...10&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;js---&quot;&gt;js - 时间戳和日期&lt;/h2&gt;
&lt;scomment&gt;# moment 控件&lt;/scomment&gt;
&lt;p style=&quot; line-height: 0px; margin-bottom: 10px; &quot;&gt;&lt;/p&gt;
&lt;scomment&gt;# http://momentjs.com/&lt;/scomment&gt;
&lt;p style=&quot; line-height: 10px; margin-bottom: 30px; &quot;&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;var time_year_month = moment().format(&#39;YYYY-MM&#39;);&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2015-03)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var time = moment(&quot;2010-10-20 4:30&quot;, &quot;YYYY-MM-DD HH:mm&quot;).format(&quot;YYYY-MMMM&quot;); &lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2010-October)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;var time = moment.unix(1427869321).format(&quot;YYYY-MM-DD HH:mm&quot;); &lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;(2015-04-01 14:22)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>合拍吧——我的第一个创业项目</title>
     <link href="http://beiyuu.com/blog/2015/03/24/%E5%90%88%E6%8B%8D%E5%90%A7.html"/>
     <updated>2015-03-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/24/合拍吧</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;感谢&lt;/h2&gt;
&lt;p&gt;感谢 陈zt 和 朱dl 二位程序猿前辈带领我做的这个app
&lt;br /&gt;
感谢 侯kl 把我安排到了这个项目&lt;/p&gt;

&lt;h2 id=&quot;app&quot;&gt;app简介&lt;/h2&gt;
&lt;blockquote&gt;&lt;p style=&quot;
    color: gray; margin-bottom: 13px;
&quot;&gt;还在独自无聊自拍？别OUT了——21世纪，没有互动就没有照片！&lt;br /&gt;
快来使用这款史无前例的合拍神器吧！&lt;br /&gt;
•眼花缭乱的合拍相纸——能够让你和各式朋友交互创造出千奇百怪的合影照片！&lt;br /&gt;
•及时分享的动态页面——让你实时掌握朋友们的每个瞬间！&lt;br /&gt;
•收纳合理的照片相集——精确归类你的各色照片！&lt;br /&gt;
•及时畅快的聊天系统——保证与合拍的TA沟通无障碍！&lt;br /&gt;
•随时查看附近潮人——三种搜索形态，各式筛选规则，让寻找趣人趣照变的易如反掌！&lt;br /&gt;
•一目了然的排行榜——闪亮的自己总会被发现，万众瞩目就在此间！&lt;br /&gt;
“与女神合体，和白马共存”不再是梦想，一切可能尽在——合——拍——吧！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这个app主要功能就是能让普(屌)通(丝)人能和自己的明星合照（参考下图）
&lt;img src=&quot;/images/1/img_paba_1.png&quot; alt=&quot;Alt text&quot; /&gt;
当然还包括了朋友圈聊天等基本的社交功能&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;制作感想&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个app主推的是拍照功能，当然这个功能肯定是大头，花了大部分时间做。
一开始，我们设计了各种背景和蒙板，还区分了横竖屏幕以及手机的4个方向来 适应我们不同的背景。
目的是为了让这个app看起来多样化，也就是绚丽多彩的功能。
可是后来发现，是我们把这个功能复杂化了，完全没有必要分4个场景的需要，就改成了一个。事实也证明这个简化是正确的，不但程序写起来方便了很多，而且根据现在的用户体验来讲，这个简化也是符合大流的。&lt;br /&gt;
我们的目的是为了让用户合拍，用户更在意的是和哪个明星，至于背景是什么，那是次要的，稍微唯美一点就基本都能接受了，不需要特别的绚丽多样。&lt;/li&gt;
  &lt;li&gt;登陆的界面，我们一共用了3个，新浪、QQ、人人。当时微信没那么火，在之后的版本中，我们把人人删了，增加了微信和手机号码。
这里我想说的是，在用第三方账号登陆的时候，尽量用native的，就是会跳转到那个app，而不要弹出一个界面让用户来输入用户名和密码之类的。
我们一开始做的是弹界面的，真的觉得很麻烦。&lt;/li&gt;
  &lt;li&gt;语音功能我们是一开始加进去的，后来发现大多数的用户还是偏向于用文字，语音的真的很少。
所以我在之后的项目中，客户如果不是特别需要，语音功能都是在2.0之后的版本才有的。&lt;/li&gt;
  &lt;li&gt;断网情况下用户是没法使用app的。这个究其原因还是我们实力不是很优秀以及但是sdk不是很完善。但是还是ios5到ios6的过度，本地保存数据的功能还处于待开发的阶段。
为了防止断网情况下的各种bug和闪退，但是就弹出登陆界面，让用户无法进入app，这个也是但是很多其他app处理断网的方法。
当然，这是一个很不好的用户体验，随着之后不断的发展，除了支付宝和各种手机银行的app等，几乎所有应用都支持断网使用。&lt;br /&gt;
这里也要感谢苹果的攻城狮的努力，才使得我们的开发变的越来越容易和简洁。&lt;/li&gt;
  &lt;li&gt;这个app在2013-11-09最后一次更新后就再也没有更新了，也就是宣告了失败。想想原因也就是运营的失败和产品本身没有足够的好，
再加上微信的迅猛发展，失败也是在情理之中的。&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>如何提升用户体验？手游用户的6个游戏阶段【转】</title>
     <link href="http://beiyuu.com/blog/2015/03/20/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C.html"/>
     <updated>2015-03-20T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/20/如何提升用户体验</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.sykong.com/2015/03/55385&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;转自：http://www.sykong.com/2015/03/55385&lt;/a&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;text&quot;&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.sykong.com/wp-content/uploads/2015/03/162.jpg&quot; class=&quot;thickbox&quot; rel=&quot;gallery-55385&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-55387&quot; src=&quot;http://www.sykong.com/wp-content/uploads/2015/03/162.jpg&quot; alt=&quot;干货 | 如何提升用户体验？手游用户的6个游戏阶段&quot; width=&quot;600&quot; height=&quot;400&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;体验是一个很难描述的东西，我们经常假设玩家的体验跟我们游戏从业者的体验是一致的。但是很多情况下，我们从业者的游戏体验不等于玩家的游戏体验。因为从业者的用户属性和主流玩家的用户属性是不同的。下面就脱离游戏设计，介绍一下玩家玩游戏的6个体验阶段：&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段一：要不要玩?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阶段一就是玩家选择游戏的过程，我们先排除口碑相传带来的新用户，因为这个时分考验游戏的综合实力，所以这里我们只把场景放在一个特定的场景：用户在应用商店中寻找游戏时！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段一所处时间：&lt;/span&gt;进游戏前的下载阶段。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.icon；&lt;/p&gt;
&lt;p&gt;2.游戏名称；&lt;/p&gt;
&lt;p&gt;3.用户评星；&lt;/p&gt;
&lt;p&gt;4.游戏截图。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;手游市场，用户选择游戏都是很被动的，所以渠道推荐什么游戏，用户就玩什么游戏，而不是像端游时期那样，用户选择好了游戏，然后去下载。由于是被动的，在应用市场上，每一个可以被用户感知的因素都有可能影响到用户是否会下载。其中最关键的就是上面列出的4个因素。IP之所以那么重要就是因为他能非常明显的体现到ICON和名字上！有IP的产品会更容易获得新增用户!&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段二：能玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阶段二就是玩家下载好游戏，并且安装好之后(因为之前的步骤我们是无法控制的)。所以我们从玩家打开游戏开始。每个人刚玩一个游戏都会有一个“最初的印象”。这个最初印象很直接的影响到玩家对游戏的期待！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段二所处时间：&lt;/span&gt;3分钟以内；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.速度：&lt;/span&gt;加载，登陆，版本更新等这些需要玩家等待的，跟游戏内容无关的东西；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.流畅度：&lt;/span&gt;是否有崩溃，是否卡顿，是否有点击没有反应的情况，这些因素都是不可抗拒的阻止玩家正常游戏的情况；&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;3.机型适配：&lt;/span&gt;机型适配是一个持续的工作，而不只是上线初期的事情，要不断优化。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;玩家在刚接触游戏的时候是很没有耐心的，如果在这个阶段让玩家遇到明显的“问题”，例如游戏闪退，游戏显示异常，一些按钮无法点击，游戏非常的卡顿……上面锁列出来的任何一个问题都很有可能让玩家感觉这是一个残次品，从而流失。&lt;/p&gt;
&lt;p&gt;除了出现明显的问题外，速度也是非常关键的！手游玩家玩游戏都是为了消遣，都在利用碎片时间在玩游戏，所以玩手机游戏的人都希望尽快玩到游戏，每一秒等待都会显得很痛苦!加上用户的使用环境错综复杂，多等几秒就可能存在没有网络的情况。手游的loading设计我认为非常重要！那是玩家对游戏的第一印象，也是玩家每天都需要等待的东西，值得花心思去优化。&lt;/p&gt;
&lt;p&gt;这个阶段考验的就是技术硬实力了，客户端优化的是否足够好，能够在大部分机型上流畅的运行，能否让玩家更快的进入游戏而不是等半天loading。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段三：好玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家只玩了一小会，这个时候玩家接触到的东西还很少，所以只能看到少量很表面的东西。如果感觉游戏还不错，愿意继续往下玩，就算是胜利!&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段三所处时间：&lt;/span&gt;3-10分钟。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.核心玩法：&lt;/span&gt;如果是已有的核心玩法，那么这个阶段就要在美术和UI/UE层面来跟竞品拉开差距。如果是创新的核心玩法，就要看目标用户是否觉得这个玩法好玩了。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.美术：&lt;/span&gt;游戏跟女人一样，美女大家都会愿意亲近，长的丑的谁都不爱搭理。美术就是游戏的脸面，美术好了玩家才有动力继续玩下去。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;3.UI/UE：&lt;/span&gt;这个部分跟游戏上手的容易程有直接关系，但是很少有人重视，不然不会出现现在这种情况：UI/UE都十分相似，并且很多体验很不好的地方。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;4.新手引导：&lt;/span&gt;新手引导不会成为加分项，只会成为减分项。新手引导的目的是让玩家从“不会玩”到“会玩”。如果玩家在新手引导之后还是不会玩，那么就很失败。如果真的存在新手引导结束后玩家还是不会玩，除了新手引导本身的设计之外，问题很可能是更底层的UI/UE。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;5.剧情：&lt;/span&gt;这里所指的剧情不是2个大头冒2个泡，出现几句对白。剧情首先要有视觉冲击力，要有酷炫的画面，合适的音乐和配音。这一步做好了也不一定是好的剧情，因为很多游戏一打开都会有一个酷炫的CG，但是CG跟游戏本身相差十万八千里，最多震撼一小会，就有从天堂掉落到现实的感觉。所以剧情不是越酷炫越好！现在很流行也是很恰当的剧情做法是结合到游戏中去，在游戏的真实场景中使用脚本做一些比较特别的剧情，来丰富游戏中的体验。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大部分游戏在核心玩法层面都很难拉开差距，而那些十分创新的玩法大部分也都不被大家所认可。所以在核心玩法上大家很难拉开差距，一旦拉开差距就是十分巨大的差距。这个阶段很大程度上是考验美术设计团队的能力，美术的好坏是最容易感受到的，也是前期影响用户最大的因素之一。交互设计是大部分游戏不被重视的一个环节，从现在市面上的游戏就能看出来，但是这个部分很重要，千万不要用新手引导来填这个部分的坑，治标不治本。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段四：会玩&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过了阶段三，玩家其实还不知道游戏到底要怎么玩，只是对核心玩法有一个初步的了解。不过随着等级的升高，玩家接触到的东西会越来越多，这个阶段就是玩家探索的过程，从接触新事物到熟悉新事物。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段四所处时间：&lt;/span&gt;3-30分钟。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.关卡设计：&lt;/span&gt;前期玩家是会在意关卡设计的，不要太难，也不要太简单。特别是关卡的丰富性和多样性，怪物的外形，技能，特点等最好多变一些，不然会快速产生疲劳感。这个阶段也可以在PVE的过程中加入一些剧情，来丰富PVE方面的体验。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.成就感：&lt;/span&gt;前期的成就感都是设计好的，不是玩家争取的，成就感主要分质变和量变。只要设计好前期的产出，合理的分布到时间轴上，持续的给玩家带来刺激，玩家就更容易持续的玩下去。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家还是因为前10分钟觉得有意思，惯性的在继续玩游戏。这个阶段还处于摸索和熟悉的阶段，玩家并没有很明确的游戏目标。所以这个阶段要通过奖励、掉落等方式持续刺玩家的神经，让玩家不要感觉到枯燥，如果玩家感觉到枯燥，第二天就可能不会回来，也就是直接影响到次日留存。&lt;/p&gt;
&lt;p&gt;另外，这个阶段是“有趣——有追求”的过渡阶段。类似“先尝后买”，这个阶段送给玩家的东西都是让玩家先体验一下，体验后觉得不错就会想要追去，目标感就自然而然的形成了。所以这个阶段不要送杂七杂八的东西，搞得玩家不明白得到了什么东西，最好直接在核心养成上让玩家不断强化。通过这种方式来慢慢树立目标感。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段五：有追求+可实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当玩家过了阶段4，探索带来的快感就没有了，所以需要帮助玩家树立自己的目标感，只有明确的目标感，才能让玩家继续留在游戏里。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段五所处时间：&lt;/span&gt;第二天至一周。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.目标感：&lt;/span&gt;缺失目标感是很多游戏的通病！玩家玩了半天不知道在玩什么，不明白自己想要什么，也不知道自己得到的那些奖励有什么用。游戏里有很多目标：任务，成就，等级，副本章节……但是这些都是游戏给玩家设计的目标感，而不是玩家自己真正想要追求的目标感，我所说的目标感是玩家自己建立的。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.新系统，新玩法：&lt;/span&gt;老的内容都会从熟悉到枯燥，需要新的内容来刺激玩家，让玩家保持一段时间的新鲜感。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段玩家的新鲜感已经过去了，新内容的开放节奏大幅放缓。玩家在这个阶段已经开始重复劳动了(不断的打副本，重复刷材料，重复刷钱…)，玩家之所以愿意重复的劳动，是因为玩家有追求的目标。上个阶段玩家的成就感都是系统送的，那么这个阶段的成就感就需要玩家去通过努力争取了。&lt;/p&gt;
&lt;p&gt;最关键的是玩家有没有想要追求的东西！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;&lt;strong&gt;阶段六：争强好胜，为了朋友&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“单机和网游最大的区别就在于互动。网游游戏就是拥有游戏元素的社区，从它的定义上来说，完全可以看出网游互动的重要。如果没有互动，那就是一个单机游戏而非网络游戏。网游中的玩家和单机游戏中的玩家的追求也是不一样的。”&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段六所处时间：&lt;/span&gt;一周以上。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;阶段性关键点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;1.社交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;2.PVP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #07a08a;&quot;&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一周之后，游戏大部分的内容玩家都已经玩过了并且很熟悉了，或者说已经枯燥了。虽然没有将游戏内容全部消耗完(打通所有副本，获得所有武将……)但是玩家对现有内容已经提不起兴趣了。&lt;/p&gt;
&lt;p&gt;巴特尔将游戏用户分为4类：成就者，探险家，社交家，杀手。长期来看，成就和探索是很难满足的，因为他们高度依赖游戏内容。社交家和杀手的需求是可以持续满足的，因为他们不消耗游戏内容，只有有玩家，有竞争，就能持续满足这2类用户的需求。所以很多游戏在很末期的时候，用户上游戏不是为了玩游戏，而是进游戏跟这些战友聊聊天。&lt;/p&gt;
  &lt;/div&gt;
</content>
   </entry>
   
   <entry>
     <title>Hello World - 如何用 Github 建立个人博客</title>
     <link href="http://beiyuu.com/blog/2015/03/18/hello-world.html"/>
     <updated>2015-03-18T00:00:00+08:00</updated>
     <id>http://beiyuu.com/blog/2015/03/18/hello-world</id>
     <content type="html">&lt;blockquote&gt;&lt;p style=&quot;
    color: gray;
&quot;&gt;某程序员退休后决定练习书法，于是重金购买文房四宝。一日，饭后突生雅兴，一番研墨拟纸，并点上上好檀香。定神片刻，泼墨挥毫，郑重地写下一行字：hello world!&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;感谢&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;感谢Github提供这样一个写博客的平台&lt;/li&gt;
  &lt;li&gt;感谢我的码友兼高中同桌&lt;a href=&quot;http://kimmykuang.github.io/&quot;&gt;Kimmy&lt;/a&gt;帮助我搭建这个博客&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-&quot;&gt;如何用 Github 建立个人博客&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Mac 环境
    &lt;ul&gt;
      &lt;li&gt;搭建好 Github 环境 &lt;a href=&quot;https://help.github.com/articles/set-up-git/&quot;&gt;安装教程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;新建一个 Repository 名字叫 yourname.github.io&lt;/li&gt;
      &lt;li&gt;提交一个 index.html 文件，然后 push 到 GitHub 的 master 分支&lt;/li&gt;
      &lt;li&gt;访问 yourname.github.io 就可以看到你上传的页面了&lt;/li&gt;
      &lt;li&gt;for example: &lt;br /&gt;
curl -X POST http://localhost:3000/smartcooler/pi -H “Content-Type:application/json” –data ‘{“type”:”temperature”, “data”:{“temp_f”:”1245”}}’
&lt;!-- + 本人是写ios出生，第一次建立网页，具体参考[这篇文章][link1] --&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;本地调试&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Mac 环境
    &lt;ul&gt;
      &lt;li&gt;安装 jekyll &lt;a href=&quot;http://kimmykuang.github.io/local-jekyll.html&quot;&gt;本地Jekyll环境的搭建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;打开 terminal 输入 &lt;code&gt;jekyll -v&lt;/code&gt; 查看版本&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre class=&quot;prettyprint linenums&quot;&gt;
  $ jekyll -v
  jekyll 2.5.3
&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;在 terminal 里 cd 到项目目录，输入 &lt;code&gt;jekyll serve --watch&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;浏览器访问 http://localhost:4000 即可&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可能遇到问题
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;/images/1/hello_world_error1.jpeg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;解决方案
        &lt;ul&gt;
          &lt;li&gt;ruby 版本到2.1.1 即可&lt;/li&gt;
          &lt;li&gt;&lt;code&gt;rvm use ruby-2.1.1&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;参考 &lt;a href=&quot;https://github.com/jekyll/jekyll/issues/2125&quot;&gt;https://github.com/jekyll/jekyll/issues/2125&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://beiyuu.com/github-pages&quot; class=&quot;external&quot; target=&quot;_blank&quot;&gt;http://beiyuu.com/github-pages&lt;/a&gt;
&lt;br /&gt;
&lt;a href=&quot;http://kimmykuang.github.io/local-jekyll.html&quot;&gt;http://kimmykuang.github.io/local-jekyll.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- 注释 --&gt;

</content>
   </entry>
   
 
</feed>
